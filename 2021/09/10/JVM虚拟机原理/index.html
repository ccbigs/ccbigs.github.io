<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JVM虚拟机原理 | ccbigs blog</title><meta name="author" content="DingQuan Zuo"><meta name="copyright" content="DingQuan Zuo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="2.内存自动管理2.1 概述内存，墙内的人想出去，墙外的人却想进来。 对于Java人员，在虚拟机的自动内存管理机制里面： 优点：  不再需要为每一个new对象配置free&#x2F;delete代码。 不容易出现内存泄漏和内存溢出的问题。  缺点：  一旦出现内存泄露和溢出，那么排查起来却是很困难的。  2.2 运行时数据区域 2.2.1 程序计数器程序计数器是一块较小的内存空间，它可以看作是当前">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM虚拟机原理">
<meta property="og:url" content="http://example.com/2021/09/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="ccbigs blog">
<meta property="og:description" content="2.内存自动管理2.1 概述内存，墙内的人想出去，墙外的人却想进来。 对于Java人员，在虚拟机的自动内存管理机制里面： 优点：  不再需要为每一个new对象配置free&#x2F;delete代码。 不容易出现内存泄漏和内存溢出的问题。  缺点：  一旦出现内存泄露和溢出，那么排查起来却是很困难的。  2.2 运行时数据区域 2.2.1 程序计数器程序计数器是一块较小的内存空间，它可以看作是当前">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/ahead.jpg">
<meta property="article:published_time" content="2021-09-10T06:23:29.000Z">
<meta property="article:modified_time" content="2024-10-22T11:06:24.816Z">
<meta property="article:author" content="DingQuan Zuo">
<meta property="article:tag" content="JAVA">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/ahead.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/09/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8E%9F%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM虚拟机原理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-22 19:06:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/ahead.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/1558.png')"><nav id="nav"><span id="blog-info"><a href="/" title="ccbigs blog"><img class="site-icon" src="/img/favicon.png"/><span class="site-name">ccbigs blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JVM虚拟机原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-10T06:23:29.000Z" title="发表于 2021-09-10 14:23:29">2021-09-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-22T11:06:24.816Z" title="更新于 2024-10-22 19:06:24">2024-10-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JAVA/">JAVA</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">39.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>119分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JVM虚拟机原理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="2-内存自动管理"><a href="#2-内存自动管理" class="headerlink" title="2.内存自动管理"></a>2.内存自动管理</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>内存，墙内的人想出去，墙外的人却想进来。</p>
<p>对于Java人员，在虚拟机的自动内存管理机制里面：</p>
<p>优点：</p>
<ol>
<li>不再需要为每一个new对象配置free&#x2F;delete代码。</li>
<li>不容易出现内存泄漏和内存溢出的问题。</li>
</ol>
<p>缺点：</p>
<ol>
<li>一旦出现内存泄露和溢出，那么排查起来却是很困难的。</li>
</ol>
<h2 id="2-2-运行时数据区域"><a href="#2-2-运行时数据区域" class="headerlink" title="2.2 运行时数据区域"></a>2.2 运行时数据区域</h2><p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211010183002837.png" alt="image-20211010183002837"></p>
<h3 id="2-2-1-程序计数器"><a href="#2-2-1-程序计数器" class="headerlink" title="2.2.1 程序计数器"></a>2.2.1 程序计数器</h3><p>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</p>
<p><strong>作用</strong></p>
<p>在Java虛拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序<strong>控制流的指示器，分支、循环、跳转、异常处理、线程恢复</strong>等基础功能都需要依赖这个计数器来完成。</p>
<p><strong>线程私有，程序计数器是唯一一个不会内存溢出的区域，详情如下：</strong></p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211010183352516.png" alt="image-20211010183352516"></p>
<h3 id="2-2-2-Java虚拟机栈"><a href="#2-2-2-Java虚拟机栈" class="headerlink" title="2.2.2 Java虚拟机栈"></a>2.2.2 Java虚拟机栈</h3><p>虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧，<strong>用于存储局部变量表、操作数栈、动态连接、方法出口等</strong>信息，执行完毕后就会出栈。</p>
<hr>
<p><strong>局部变量表</strong></p>
<p>局部变量表存放了编译期可知的各种Java虚拟机基本数据类型、对象引用和returnAddress类型。</p>
<p>这些数据类型在局部变量表中的存储空间以局部变量槽(Slot)来表示，其中long、double会占用两个槽，<strong>局部变量表所需的内存空间在编译期间完成分配</strong>。</p>
<hr>
<p><strong>异常</strong></p>
<p>StackOverflowError异常：如果线程请求的栈深度大于虚拟机所允许的深度会抛出。</p>
<p>OutOfMemoryError异常：如果Java虚拟机栈容量可以动态扩展，当扩展时无法申请到足够的内存会抛出该异常。</p>
<p><strong>值得注意的是，以上情况出现在Classic虚拟机上，但是Hotpot虚拟机的栈容量不可以扩展的，所以只会出现OOM。</strong></p>
<h3 id="2-2-3-本地方法栈"><a href="#2-2-3-本地方法栈" class="headerlink" title="2.2.3 本地方法栈"></a>2.2.3 本地方法栈</h3><p>本地方法栈和虚拟机栈是非常相似的，<strong>不同的是：</strong>虚拟机栈为虚拟机执行Java方法服务，<strong>而本地方法栈则是为虚拟机使用到的本地(Native)方法服务。</strong></p>
<p><strong>本地方法：</strong>本地方法是由其它语言编写的，编译成和处理器相关的机器代码。</p>
<hr>
<p><strong>异常</strong></p>
<p>同上。</p>
<h3 id="2-2-4-Java堆"><a href="#2-2-4-Java堆" class="headerlink" title="2.2.4 Java堆"></a>2.2.4 Java堆</h3><p><strong>《Java虚拟机规范》中对Java堆的描述：所有的对象实例以及数组都应当在堆上分配。</strong></p>
<hr>
<p>特点：</p>
<ol>
<li>是虚拟所管理的内存中最大的一块。</li>
<li>Java堆是被所有线程共享的一块内存区域。</li>
<li>Java堆也是垃圾收集器管理的内存区域，因此一些资料也将他称为“GC堆”</li>
</ol>
<hr>
<p><strong>异常</strong></p>
<p>如果在Java堆中没有内存完成分配，并且堆也无法再扩展时，Java堆会抛出OOM异常。</p>
<h3 id="2-2-5-方法区"><a href="#2-2-5-方法区" class="headerlink" title="2.2.5 方法区"></a>2.2.5 方法区</h3><p>方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。别名“非堆”。</p>
<hr>
<p><strong>历史</strong></p>
<p>在JDK8以前，许多Java程序员更愿意把方法区称呼为“永久代”。</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211010232925471.png" alt="image-20211010232925471"></p>
<hr>
<p><strong>方法区的垃圾收集行为</strong></p>
<p>《Java虚拟机规范》对方法区的约束是非常宽松的，同时垃圾收集行为在这个区域比较少出现。<strong>这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载</strong>。但是这个区域的回收效果不是很好。</p>
<hr>
<p><strong>异常</strong></p>
<p>如果方法区无法满足新的内存分配需求时，将会抛出OOM异常。</p>
<h3 id="2-2-6-运行时常量池"><a href="#2-2-6-运行时常量池" class="headerlink" title="2.2.6 运行时常量池"></a>2.2.6 运行时常量池</h3><p><strong>运行时常量池是方法区的一部分</strong>，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放<strong>编译器生成的各种字面量与符号引用</strong>，这部分内容将在类加载后存放到方法去的运行时常量池中。</p>
<hr>
<p><strong>动态性</strong></p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211010233810243.png" alt="image-20211010233810243"></p>
<hr>
<p><strong>异常</strong></p>
<p>运行时常量池会受到方法区的内存限制，当常量池无法申请到内存时会抛出OOM异常。</p>
<h3 id="2-2-7-直接内存"><a href="#2-2-7-直接内存" class="headerlink" title="2.2.7 直接内存"></a>2.2.7 直接内存</h3><p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211010234030891.png" alt="image-20211010234030891"></p>
<h2 id="2-3-HotSpot虚拟机对象解密"><a href="#2-3-HotSpot虚拟机对象解密" class="headerlink" title="2.3 HotSpot虚拟机对象解密"></a>2.3 HotSpot虚拟机对象解密</h2><h3 id="2-3-1-对象的创建"><a href="#2-3-1-对象的创建" class="headerlink" title="2.3.1 对象的创建"></a>2.3.1 对象的创建</h3><blockquote>
<p>遇到new指令时</p>
</blockquote>
<p>当Java虚拟机遇到一个字节码new指令时。</p>
<p>首先会去<strong>检查这个指令的参数是否能在常量池中定位到一个类的符号引用</strong>，并且检查这个符号引用代表的类是否被加载、解析和初始化过。</p>
<p>如果没有，那么必须执行类的加载过程(加载、检查、准备、解析、初始化)</p>
<blockquote>
<p>类加载后？</p>
</blockquote>
<p>类加载检查通过后，接下来虚拟机会为新生对象分配内存。<strong>对象所需内存的大小在类加载完成后便可完全确定</strong>。</p>
<p><strong>划分内存：</strong></p>
<ol>
<li>如果Java堆中内存是绝对规整的，那么只需一个指针作为分界点的指示器，对象需要多少内存，就移出多少内存。我们称这种方式为<strong>指针碰撞</strong>。</li>
<li>如果Java堆中的内存不是规整的，那么虚拟机就必须维护一个表，记录那些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表的记录，这种分配方式称为<strong>空闲列表</strong>。</li>
</ol>
<p><strong>分配安全</strong></p>
<p>在线程并发情况下，可能会出现正在给对象A分配一块内存，但指针还没来得及修改，对象B又使用了原来的指针进行分配，这就会造成内存不安全。</p>
<ol>
<li>解决方案1：对分配内存空间的操作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性。</li>
<li>解决方案2：把内存分配的动作按照线程划分在不同空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲(TLAB)</li>
</ol>
<blockquote>
<p>分配内存之后该怎么做?</p>
</blockquote>
<p>Java虚拟机会将必要的信息存放到对象的对象头中，其中包括这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄信息等。</p>
<blockquote>
<p>分配好对象头之后，对象创建才刚刚开始(Java程序的角度)</p>
</blockquote>
<p>目前对象的构造函数，即Class文件中的<init>()方法还没执行，所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。new指令之后会接着执行<init>（）方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。</p>
<h3 id="2-3-2-对象的内存布局"><a href="#2-3-2-对象的内存布局" class="headerlink" title="2.3.2 对象的内存布局"></a>2.3.2 对象的内存布局</h3><p><strong>在HotSpot虚拟机中，对象在堆内存中的存储布局可以划分为三个部分：对象头、实例数据、对齐填充。</strong></p>
<hr>
<blockquote>
<p>对象头结构</p>
</blockquote>
<p>HotSpot虚拟机对象的对象头部分包括两类信息。</p>
<p>第一类是用于存储<strong>对象自身的运行时数据</strong>，如哈希码(HashCode) 、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，官方称它为“MarkWord?。MarkWord被设计成一个有着动态定义的数据结构。</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211014222344173.png" alt="image-20211014222344173"></p>
<p>对象头的另外一部分是<strong>类型指针</strong>，即<strong>对象指向它的类型元数据的指针，Java虛拟机通过这个指针来确定该对象是哪个类的实例</strong>。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身，这点我们会在下一节具体讨论。此外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。</p>
<hr>
<blockquote>
<p>对象第二部分数据(内存)</p>
</blockquote>
<p>接下来实例数据部分是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。</p>
<hr>
<blockquote>
<p>对象第三部分</p>
</blockquote>
<p>对象的第三部分是<strong>对齐填充</strong>，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数(1倍或者2倍)，因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p>
<h3 id="2-3-3-对象的访问定位"><a href="#2-3-3-对象的访问定位" class="headerlink" title="2.3.3 对象的访问定位"></a>2.3.3 对象的访问定位</h3><p>创建对象自然是为了后续使用该对象，我们的Java程序会通过栈上的reference数据来操作堆上的具体对象。由于reference类型在《Java虚拟机规范》里面只规定了它是-一个指向对象的引用，并没有定义这个引用应该通过什么方式去定位、访问到堆中对象的具体位置，所以对象访问方式也是由虚拟机实现而定的，主流的访问方式主要有使用句柄和直接指针两种:</p>
<ul>
<li><p>句柄：:如果使用句柄访问的话，<strong>Java堆中将可能会划分出一块内存来作为句柄池</strong>，reference中存储的就是对象的句柄地址，而句柄中包含了<strong>对象实例数据</strong>与<strong>类型数据</strong>各自具体的<strong>地址信息</strong>，其结构如图2-2所。</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211014224214283.png" alt="image-20211014224214283"></p>
</li>
<li><p>.如果使用<strong>直接指针</strong>访问的话，Java堆中对象的内存布局就必须考虑如何放置访问<strong>类型数据的相关信息</strong>，reference中存储的直接就是对象地址，如果<strong>只是访问对象本身的话，就不需要多一次间接访问的开销</strong>，如图2-3所示。</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211014224342349.png" alt="image-20211014224342349"></p>
</li>
</ul>
<hr>
<p><strong>两者的区别</strong></p>
<p><strong>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销</strong>，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本，就本书讨论的主要虚拟机<strong>HotSpot</strong>而言，它主要使用第二种方式进行对象访问。</p>
<h1 id="3-垃圾收集器与回收策略"><a href="#3-垃圾收集器与回收策略" class="headerlink" title="3.垃圾收集器与回收策略"></a>3.垃圾收集器与回收策略</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p>当需要排查各种内存溢出、内存泄露问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们必须要对这些“自动化”的技术实施必要的监控和调节。</p>
<h2 id="3-2-对象已死？"><a href="#3-2-对象已死？" class="headerlink" title="3.2 对象已死？"></a>3.2 对象已死？</h2><p>如何判断一个对象是否存活(即是否还分配在堆中)，那看他是否还在用。</p>
<h3 id="3-2-1-引用计数算法"><a href="#3-2-1-引用计数算法" class="headerlink" title="3.2.1 引用计数算法"></a>3.2.1 引用计数算法</h3><p>这是一种判断方式，相应的方法就是：如果一个对象被引用，那将被引用的对象中的一个计数器加一，引用失效就减一。在任何时刻引用计数器为0那就是没有应用的话，那该对象就可被回收了。</p>
<p><strong>存在着的缺陷</strong>：当两个对象相互引用的时候，就会造成一种循环，引用计数器无法判断他们是否还有用。</p>
<p>Java虚拟机不用这种。</p>
<h3 id="3-2-2-可达性分析算法"><a href="#3-2-2-可达性分析算法" class="headerlink" title="3.2.2 可达性分析算法"></a>3.2.2 可达性分析算法</h3><p>通过“GC Roots”的跟对象作为起始节点集，从这些结点开始，根据应用关系向下搜索，搜索过程中走过的路径叫做引用链，如果某个对象(或某个对象链)不在引用链上，会被标记为可回收对象(关于是否可以真正回收可以查看3.2.4)。</p>
<p>被固定可作为GCRoot对象有以下几种：</p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>静态属性引用对象</li>
<li>常量引用对象</li>
<li>本地方发展中Native方法引用的对象</li>
<li>一些常驻的异常对象</li>
<li>被同步锁持有的对象</li>
<li>反应Java虚拟机内部信息的对象(一些工具)</li>
</ul>
<h3 id="3-2-3-再谈引用"><a href="#3-2-3-再谈引用" class="headerlink" title="3.2.3 再谈引用"></a>3.2.3 再谈引用</h3><p>无论是引用计数算法还是可达性分析算法判断对象是否可以被回收，我们都离不开引用的关系。</p>
<p>JDK1.2版本：<strong>强引用、软引用、弱引用、虚引用</strong></p>
<p><strong>强引用</strong>：是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，<strong>即类似“Object</strong> <strong>obj&#x3D;new Object()”这种引用关系</strong>。无论任何情况下，<strong>只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象</strong>。</p>
<p><strong>软引用：是用来描述一些还有用，但非必须的对象</strong>。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。</p>
<p><strong>弱引用：也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止</strong>。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。</p>
<p><strong>虚引用：也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系</strong>。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得–一个对象实例。为-一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器凹收时收到一个系统通知。在JDK1.2版之后提供了PhantomReference类来实现虚引用。</p>
<h3 id="3-2-4-生存还是死亡"><a href="#3-2-4-生存还是死亡" class="headerlink" title="3.2.4 生存还是死亡?"></a>3.2.4 生存还是死亡?</h3><p><strong>可达性算法补充。</strong></p>
<p>可达性算法判定为不可达对象后，这个对象还不是“非死不可”，这个对象要真正死亡，还需要至少经历两次标记过程。</p>
<p>第一次标记：可达性分析算法发现没有和GC Root相连，会被第一次标记。</p>
<p>中间流程：如果对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用了，那么虚拟机就会直接调用（finalize方法只能被执行一次）。</p>
<p>第二次标记：如果该对象finalize方法判定为有必要执行，那就会把该对象放到F-Queue队列中。finalize方法是对象逃脱死亡命运的最后一次机会，如果这时候该对象和GC Root上的引用链连接上了，那么就可以逃脱被回收的命运，不然就会被回收。</p>
<h3 id="3-2-5-回收方法区"><a href="#3-2-5-回收方法区" class="headerlink" title="3.2.5 回收方法区"></a>3.2.5 回收方法区</h3><p>方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。</p>
<p><strong>判断常量是否可以被回收:</strong></p>
<ol>
<li>没有任何字符串对象引用该常量，且虚拟机中也没有其他地方引用这个字面量。</li>
</ol>
<p><strong>判定一个类型是否属于“不再被使用的类”：</strong></p>
<ol>
<li>该类所有的实例都已被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，否则通常很难达成的。</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类方法。</li>
</ol>
<h2 id="3-3-垃圾收集算法"><a href="#3-3-垃圾收集算法" class="headerlink" title="3.3 垃圾收集算法"></a>3.3 垃圾收集算法</h2><p>从如何判定消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”和“追踪式垃圾收集”两大类。</p>
<p>本文主要介绍的是<strong>追踪式垃圾收集</strong>。</p>
<h3 id="3-3-1-分代收集理论"><a href="#3-3-1-分代收集理论" class="headerlink" title="3.3.1 分代收集理论"></a>3.3.1 分代收集理论</h3><p>当代垃圾收集器大多遵循“分代收集”的理论进行设计，它建立在两个假说之上：</p>
<ul>
<li>弱分代假说：绝大多数对象都是朝生夕灭的。</li>
<li>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。</li>
</ul>
<p>以上两个假说共同奠定多款垃圾收集器的设计原则：收集器应将Java堆划分出不同的区域，然后将回收对象依据其年龄分配到不同的区域中存储。</p>
<p><strong>回收类型划分：</strong>将Java堆划分出不同区域之后，垃圾收集器每次只回收其中某一个或某部分区域——因而才有“Minor GC”、“Major GC”、“Full GC”这样的回收类型划分。同时也发展出“标记-复制算法”，“标记-清除算法”、“标记-整理算法”等针对性的收集算法。</p>
<p><strong>第三个假说的添加：</strong></p>
<ul>
<li>跨代引用假说：跨代引用相对于同代引用来说仅占极少数。存在互相引用关系的两个对象，是应该倾向于同时生存或同时消亡。</li>
</ul>
<p><strong>垃圾收集器名词：</strong></p>
<ul>
<li>部分收集(Partial GC)：指目标不是完整手机整个Java堆的垃圾收集，其中又分为<ul>
<li>新生代收集(Minor GC)：指目标只是新生代的垃圾收集。</li>
<li>老年代收集(Major GC)：指目标只是老年代的垃圾收集。。目前只有CMS收集器会有单独收集老年代的行为。</li>
<li>混合收集(Mixed GC)：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</li>
</ul>
</li>
<li>整堆收集：收集整个Java堆和方法去的垃圾收集。</li>
</ul>
<h3 id="3-3-2-标记-清除算法"><a href="#3-3-2-标记-清除算法" class="headerlink" title="3.3.2 标记-清除算法"></a>3.3.2 标记-清除算法</h3><p><strong>标签</strong>：最早出现也是最基础的垃圾收集算法。</p>
<p><strong>过程：</strong>首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象。也可以反过来。</p>
<hr>
<p><strong>优点：</strong></p>
<p><strong>缺点：</strong></p>
<ul>
<li>执行效率不稳定。</li>
<li>产生空间碎片化问题，对清除后的对象分配内存不利。</li>
</ul>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211016100732557.png" alt="image-20211016100732557"></p>
<h3 id="3-3-3-标记-复制算法"><a href="#3-3-3-标记-复制算法" class="headerlink" title="3.3.3 标记-复制算法"></a>3.3.3 标记-复制算法</h3><p><strong>标签：</strong>为了解决标记-清除算法面对大量可回收对象时执行效率低的问题。</p>
<p><strong>过程：</strong>将内存划分为两块相等的大小，每次只使用其中的一块。进行垃圾收集时，将存活的对象复制到另外一块，再把使用的内存块清理掉。</p>
<hr>
<p><strong>优点：</strong>实现简单，运行高效</p>
<p><strong>缺点</strong>：代价是将可用内存空间缩小一半。</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211016101822341.png" alt="image-20211016101822341"></p>
<hr>
<p><strong>附录</strong></p>
<p><strong>现在商业Java虚拟机大多采用这种算法进行收集</strong>，IBM曾进行过统计，新生代的百分之98的对象都熬不多第一次收集，因此不必用1：1比例来划分空间。</p>
<hr>
<p><strong>理论进阶</strong>（HotSpot使用的）</p>
<p>“Appel 回收”：Appel式回收把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。</p>
<p><strong>过程：</strong>发生垃圾收集时，将Eden和Survivor中仍存活的对象一次性复制到另外一块Survivor上，然后清理Eden和已使用的Survivor。当Survivor空间不足以容纳一次Minor GC之后的存活对象，就需要老年代进行分担。</p>
<h3 id="3-3-5-标记-整理算法"><a href="#3-3-5-标记-整理算法" class="headerlink" title="3.3.5 标记-整理算法"></a>3.3.5 标记-整理算法</h3><p><strong>标签：</strong>在对象存活率较高时就要进行较多的复制操作，效率会更低，对标记-清除算法的一种改进。</p>
<p><strong>过程：</strong>发生垃圾收集时，将存活的对象标记，然后清除回收未标记的对象，然后再进行排序。</p>
<hr>
<p><strong>优点：</strong>合理利用空间，内存空间划分规整。</p>
<p><strong>缺点：</strong>在进行整理的时候，会暂停对象的分配，我们称之为“stop the world”。</p>
<h2 id="3-4-HotSpot的算法细节实现"><a href="#3-4-HotSpot的算法细节实现" class="headerlink" title="3.4 HotSpot的算法细节实现"></a>3.4 HotSpot的算法细节实现</h2><h3 id="3-4-1-根节点枚举"><a href="#3-4-1-根节点枚举" class="headerlink" title="3.4.1 根节点枚举"></a>3.4.1 根节点枚举</h3><h3 id="3-4-2-安全点"><a href="#3-4-2-安全点" class="headerlink" title="3.4.2 安全点"></a>3.4.2 安全点</h3><p>OopMap在特定的位置记录的信息，我们将这些位置称之为<strong>安全点</strong>。</p>
<p><strong>作用：</strong>几乎完美解决如何停顿用户线程，让虚拟机进入垃圾回收状态。安全点的选定可以让收集器的等待时间适中。</p>
<p><strong>选取标准：</strong>是否具有让程序长时间执行的特征</p>
<p><strong>产生点：</strong>方法调用、循环跳转、异常跳转。</p>
<hr>
<p><strong>如何让线程跑到最近的安全点，让后停顿：</strong></p>
<ul>
<li>抢先式中断：抢先式中断不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。现在几乎没有虚以机实现采用抢先式中断来暂停线程响应GC事件。</li>
<li>主动式中断：而主动式中断的思想是当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去<strong>轮询</strong>这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。<strong>轮询标志的地方和安全点是重合的</strong>，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。</li>
</ul>
<p>由于轮询操作在代码中会频繁出现，这要求它<strong>必须足够高效</strong>。HotSpot使用<strong>内存保护陷阱的方式</strong>， 把轮询操作精简至只有一条汇编指令的程度。下面代码清单3-4中的test指令就是HotSpot生成的轮询指令，当需要暂停用户线程时，虚拟机把0xl 60100的内存页设置为不可读，那线程执行到test指令时就会产生一个自陷异常信号，然后在预先注册的异常处理器中挂起线程实现等待，这样仅通过一条汇编指令便完成安全点轮询和触发线程中断了。</p>
<h3 id="3-4-3-安全区域"><a href="#3-4-3-安全区域" class="headerlink" title="3.4.3 安全区域"></a>3.4.3 安全区域</h3><p><strong>标签：</strong>解决安全点的不足之处，就是程序没有分配处理器的时间，可以看作是安全点的拉伸。</p>
<p><strong>作用：</strong>处理Sleep状态或Blocked状态无法响应虚拟机的中断请求。</p>
<p>概念：安全区域确保在某一段代码片段中，引用关系不会发生变化。</p>
<hr>
<p><strong>收集安全：</strong>当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举(或者垃圾收集过程中其他需要暂停用户线程的阶段)，如果完成了，那线程就当作没事发生过，继续执行;否则它就必须一直等待，直到收到可以离开安全区域的信号为止。</p>
<h3 id="3-4-4-记忆集与卡表"><a href="#3-4-4-记忆集与卡表" class="headerlink" title="3.4.4 记忆集与卡表"></a>3.4.4 记忆集与卡表</h3><p><strong>作用：</strong>解决对象跨代引用所带来的问题，垃圾收集器在新生代中建立了记忆集的数据接口，避免把整个老年代加入GC Roots扫描范围。</p>
<hr>
<p><strong>面临问题：</strong></p>
<p>垃圾收集场景中，只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针就可以了。</p>
<p>为此，下面列举了一些可供选择的记录精度：</p>
<ul>
<li><strong>字长精度</strong>:每个记录精确到一个机器字长(就是处理器的寻址位数，如常见的32位或64位，这个精度决定了机器访问物理内存地址的指针长度)，该字包含跨代指针。</li>
<li><strong>对象精度</strong>:每个记录精确到-一个对象，该对象里有字段含有跨代指针。</li>
<li><strong>卡精度(卡表[字节数组]，目前最常用)</strong>:每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</li>
</ul>
<h3 id="3-4-5-写屏障"><a href="#3-4-5-写屏障" class="headerlink" title="3.4.5 写屏障"></a>3.4.5 写屏障</h3><p><strong>作用：</strong>我们已经解决了如何使用记忆集来缩减GC Roots扫描范围的问题，写屏障将解决<strong>卡表元素如何维护的问题</strong>，例如它们何时变脏、谁来把它们变脏等。</p>
<hr>
<p><strong>卡表元素变脏过程：</strong>有其他分代区域中的对象引用了本区域对象，其对应的卡表元素就应该变脏，变脏时间点原则上应该发生在引用类型字段赋值的那一刻。</p>
<hr>
<p><strong>过程：</strong>写屏障可以看作在虛拟机层面对“引用类型字段赋值’这个动作的AOP切面，在引用对象赋值时会产生一个环形(Around) 通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内。在赋值前的部分的写屏障叫作写前屏障(Pre-WriteBarrier)，在赋值后的则叫作写后屏障(Post-WriteBarrier)。</p>
<p><strong>HotSpot虚拟机的许多收集器中都有使用到写屏障，但直至G1收集器出现之前，其他收集器都只用到了写后屏障</strong>。</p>
<p>写屏障相对于Minor GC时少秒整个老年代的代价相比还是低的多的。</p>
<hr>
<p><strong>卡表在高并发场景面临“伪共享”问题</strong>：</p>
<h3 id="3-4-6-并发的可达性分析"><a href="#3-4-6-并发的可达性分析" class="headerlink" title="3.4.6 并发的可达性分析"></a>3.4.6 并发的可达性分析</h3><p>可达性分析算法理论上要求全过程都基于一个能保障一致性的快照中才能够进行分析，这意味着必须全程冻结用户线程的进行。</p>
<p><strong>增量更新和原始快照</strong></p>
<h2 id="3-5-经典垃圾收集器"><a href="#3-5-经典垃圾收集器" class="headerlink" title="3.5 经典垃圾收集器"></a>3.5 经典垃圾收集器</h2><p><strong>收集算法是内存回收的方法论，那垃圾收集器就是内存回收的实践者</strong></p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211016143724065.png" alt="image-20211016143724065"></p>
<p>上图展示了七种作用于不同分代的收集器，<strong>如果两个收集器之间存在连线，就说明他们可以搭配使用</strong>。图中收集器所在的区域，则表示它是属于<strong>新生代收集器抑或是老年代收集器</strong>。</p>
<h3 id="3-5-1-Serial收集器"><a href="#3-5-1-Serial收集器" class="headerlink" title="3.5.1 Serial收集器"></a>3.5.1 Serial收集器</h3><p>色瑞亚</p>
<p>Serial收集器是最基础、历史悠久的收集器，同时他也是一个单线程工作的收集器。</p>
<p><strong>优点：</strong>与其他收集器相比，简单而高效、它是所有收集器里消耗最小的，同时效率最高的单线程。</p>
<p><strong>缺点：</strong>会“Stop the World”</p>
<hr>
<p><strong>当前：</strong>依旧是HotSpot虚拟机运行在客户端下默认的新生代收集器。</p>
<p><strong>推荐：</strong>在客户端使用。</p>
<hr>
<p><strong>算法：</strong>标记-复制</p>
<h3 id="3-5-2-ParNew收集器"><a href="#3-5-2-ParNew收集器" class="headerlink" title="3.5.2 ParNew收集器"></a>3.5.2 ParNew收集器</h3><p>把牛</p>
<p>ParNew收集器实质上是Serial收集器的多线程并行版本。</p>
<p><strong>优点：</strong>低概率出现“Stop the world”</p>
<p><strong>缺点：</strong>存在线程交互的开销，效率比Serial低。</p>
<hr>
<p><strong>当前：</strong>JDK9前使用ParNew搭配CMS</p>
<p><strong>推荐：</strong>服务端</p>
<hr>
<p><strong>算法：</strong>标记-复制</p>
<h3 id="3-5-3-Parallel-Scavenge收集器"><a href="#3-5-3-Parallel-Scavenge收集器" class="headerlink" title="3.5.3 Parallel Scavenge收集器"></a>3.5.3 Parallel Scavenge收集器</h3><p>派瑞啦斯堪瑞吉</p>
<p>Parallel Scavenge目标是达到一个可控制的吞吐量：</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211016151113307.png" alt="image-20211016151113307"></p>
<p>用户可以设置控制最大垃圾收集停顿时间，和直接设置吞吐量大小。</p>
<hr>
<p><strong>算法：</strong>标记-复制</p>
<h3 id="3-5-4-Serial-Old收集器"><a href="#3-5-4-Serial-Old收集器" class="headerlink" title="3.5.4 Serial Old收集器"></a>3.5.4 Serial Old收集器</h3><p>Serial Old收集器是Serial收集器的老年代版本，使用单线程。</p>
<p><strong>优点：</strong>单线程，快</p>
<p><strong>缺点：</strong>可能会出现“Stop the world”</p>
<hr>
<p><strong>当前：</strong>JDK5之前是Parallel+Scavenge的后备预案。</p>
<p><strong>推荐：</strong>客户端</p>
<hr>
<p><strong>算法：</strong>标记-整理</p>
<h3 id="3-5-5-Parallel-old-收集器"><a href="#3-5-5-Parallel-old-收集器" class="headerlink" title="3.5.5 Parallel old 收集器"></a>3.5.5 Parallel old 收集器</h3><p>Parallel Scavenge收集器的老年代版本，使用多线程并发收集。</p>
<p><strong>优点：</strong>降低“Stop the world”的概率</p>
<p><strong>缺点：</strong>加大系统资源的使用</p>
<hr>
<p><strong>当前：</strong>JDK5之前是Parallel+Scavenge的后备预案。</p>
<p><strong>推荐：</strong>注重吞吐率和处理资源较为稀缺的环境。比如大数据</p>
<hr>
<p><strong>算法：</strong>标记-整理</p>
<h3 id="3-5-6-CMS收集器"><a href="#3-5-6-CMS收集器" class="headerlink" title="3.5.6 CMS收集器"></a>3.5.6 CMS收集器</h3><p>CMS收集器是一种以获取最短回收停顿时间为目标的收集器。</p>
<p><strong>优点：</strong>并发收集、低停顿</p>
<p><strong>缺点：</strong><code>CMS收集器对处理器资源非常敏感</code>，<code>CMS无法处理“浮动垃圾”，有可能出现并发失败而进行Full GC</code>，<code>标记-清除会产生大量碎片化空间</code></p>
<hr>
<p><strong>当前：</strong>JDK5之前是Parallel+Scavenge的后备预案。</p>
<p><strong>推荐：</strong>系统停顿时间尽可能短，已给客户带来更好的交互体验。B&#x2F;S系统</p>
<hr>
<p><strong>算法：</strong>标记-清除算法</p>
<p><strong>标记阶段并发：</strong>增量更新</p>
<hr>
<p><strong>运作过程</strong></p>
<ol>
<li>初始标记：标记一下GC Roots能直接关联到的对象，速度很快，会“STW”</li>
<li>并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，耗时较长</li>
<li>重新标记：为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。会“STW”</li>
<li>并发清除：清理删除标记阶段判断已经死亡的对象。</li>
</ol>
<h3 id="3-5-7-G1收集器"><a href="#3-5-7-G1收集器" class="headerlink" title="3.5.7 G1收集器"></a>3.5.7 G1收集器</h3><p>Garbage First ( 简称G1)收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集<br>器面向局部收集的设计思路和基于Region的内存布局形式。被官方称之为“全能的垃圾回收器”。</p>
<p><strong>目标：</strong>在延迟可控的情况下获得尽可能高的吞吐量。</p>
<p><strong>特点：</strong>G1面向堆内存来组成回收集来进行回收，衡量标准不再是它属于哪个分代，而是哪块内存内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。</p>
<p><strong>Region堆：实现Mixed GC模式的关键。</strong>G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域(Region)，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。</p>
<p><strong>Humongous区域：</strong>Region中还有一类特殊的Humongous区域，专门用来存储大对象，只要改对象大小超过Region容量一般就判定为大对象。</p>
<p>更具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间(使用参数-XX: M axGCPauseMilis指定，默认值是200毫秒)，优先处理回收价值收益最大的那些Region，这也就是“Garbage First”名字的由来。这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211016162551198.png" alt="image-20211016162551198"></p>
<hr>
<p><strong>缺点：</strong></p>
<ol>
<li>跨Region对象的回收要比其他收集器的效率低。</li>
<li>并发标记阶段，如果内存回收的速度赶不上内存分配的速度，G1会冻结用户线程，导致触发Full GC而产生的“STW”。</li>
</ol>
<hr>
<p><strong>运行过程步骤：</strong></p>
<ol>
<li>初始标记( Initial Marking) ：<strong>仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值</strong>，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行MinorGC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</li>
<li>并发标记(Concurrent Marking) :<strong>从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行</strong>。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。</li>
<li>最终标记(FinalMarking):对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。</li>
<li>筛选回收( Live Data Counting and Evacuation) :<strong>负责更新Region的统计数据，对各个Region的回收价值和成本进行排序</strong>，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部 分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。</li>
</ol>
<hr>
<p><strong>整体看：</strong>标记-清除</p>
<p><strong>局部看：</strong>标记-复制</p>
<p><strong>标记阶段并发：</strong>原始快照</p>
<h2 id="3-6-低延迟垃圾收集器"><a href="#3-6-低延迟垃圾收集器" class="headerlink" title="3.6 低延迟垃圾收集器"></a>3.6 低延迟垃圾收集器</h2><p>衡量垃圾收集器的三项最重要的指标：<strong>内存占用、吞吐量、延迟</strong>。</p>
<p>目前处于实验状态的垃圾收集器：Shenandoah、ZGC可以在任意可管理的对容量下，实现停顿不超过十毫秒这种天方夜谭的话。</p>
<h3 id="3-6-1-shenandoah收集器"><a href="#3-6-1-shenandoah收集器" class="headerlink" title="3.6.1 shenandoah收集器"></a>3.6.1 shenandoah收集器</h3><p>珊娜都拉</p>
<p><strong>背景故事：</strong>RedHat开发的，被排挤。</p>
<p><strong>目标：</strong>实现一种能在任何堆内存大小下都可以吧垃圾收集的停顿时间限制在十毫秒以内的垃圾收集器。</p>
<p><strong>结构：</strong>Shenandoah的结构和G1的结构基本相同。但有三个不同之处：</p>
<ol>
<li>支持与用户线程一起并发的整理算法。</li>
<li>默认不使用分代。</li>
<li>用“链接矩阵”的全局数据结构<strong>替代</strong>记忆表来记录跨Region的引用关系，降低伪共享的发生概率。</li>
</ol>
<hr>
<p><strong>工作过程</strong>：</p>
<ol>
<li><strong>初始标记：</strong>与G1一样，首先标记与GC Roots直接关联的对象， 这个阶段仍是“Stop The World”的，但停顿时间与堆大小无关，只与GC Roots的数量相关。</li>
<li><strong>并发标记</strong>(Concurrent Marking) :与G1一样，遍历对象图，标记出全部可达的对象，这个阶段是与用户线程一起并发的，时间长短取决于堆中存活对象的数量以及对象图的结构复杂程度。</li>
<li><strong>最终标记(Final Marking)</strong> :与G1一样，处理剩余的SATB扫描，并在这个阶段统计出回收价值最高的Region,将这些Region构成一组回收集(Collection Set)。最终标记阶段也会有一小段短暂的停顿。</li>
<li><strong>并发回收：</strong>并发回收阶段是Shenandoah与之前HotSpot中其他收集器的<strong>核心差异</strong>。在这个阶段，Shenandoah要把回收集里面的存活对象先复制一份到其他未被使用的Region之中。复制对象这件事情如果将用户线程冻结起来再做那是相当简单的，但如果两者必须要同时并发进行的话，就变得复杂起来了。<strong>其困难点是在移动对象的同时，用户线程仍然可能不停对被移动的对象进行读写访问，移动对象是一次性的行为，但移动之后整个内存中所有指向该对象的引用都还是旧对象的地址，这是很难一瞬间全部改变过来的。对于并发回收阶段遇到的这些困难，Shenandoah将会通过读屏障和被称为“Brooks Pointers”的转发指针来解决(讲解完Shenandoah整个工作过程之后笔者还要再回头介绍它)。并发回收阶段运行的时间长短取决于回收集的大小</strong>。</li>
<li><strong>初始引用更新：</strong>并发回收阶段复制对象后，还需要把堆中所有指向就对象的引用修正到复制后的新地址，这个操作称为引用更新。</li>
<li><strong>并发引用更新：</strong>真正开始进行引用更新操作，这个阶段是与用户线程一起并发的，时间长短取决于内存中涉及的引用数量的多少。</li>
<li><strong>最终引用更新：</strong>解决了堆中的引用更新后，还要修正存在于GC Roots中的引用。</li>
<li><strong>并发清理：</strong>经过并发回收和引用更新之后，整个回收集中所有的Region已再无存活对象，这些Region都变成Immediate Garbage Regions了，最后再调用一-次并发清理过程来回收这些Region的内存空间，供以后新对象分配使用。</li>
</ol>
<p>我们只需要抓住以上三个重要的并发阶段：<strong>并发标记、并发回收、并发应用更新</strong>，就能理清Shenandoah是如何运作的了。</p>
<p><strong>其他细节点阅读书上的104页</strong></p>
<h3 id="3-6-2-ZGC收集器"><a href="#3-6-2-ZGC收集器" class="headerlink" title="3.6.2 ZGC收集器"></a>3.6.2 ZGC收集器</h3><p><strong>ZGC收集器是一款基于Region内存布局的，不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，已低延迟为首要目标的一款垃圾收集器</strong></p>
<hr>
<p><strong>特点：</strong></p>
<p><strong>Region</strong>：ZGC的Region具有动态性——动态创建和销毁，以及动态的区域容量大小。在X64硬件平台下，ZGC的Region具有大、中、小三类容量：</p>
<ol>
<li>小型Region ( Small Region) :容量固定为2MB，用于放置小于256KB的小对象。</li>
<li>中型Region ( M edium Region) :容量固定为32MB，用于放置大于等于256KB但小于4M B的对象。</li>
<li>大型Region (Large Region) :<strong>容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象</strong>。每个大型Region中只会存放一个大对象，这也预示着虽然名字叫作“大型Region”，但它的实际容量完全有<strong>可能小于中型Region</strong>，最小容量可低至4MB。大型Region在ZGC的实现中是不会被重分配(重分配是ZGC的一-种处理动作，用于复制对象的收集器阶段，稍后会介绍到)的，因为复制一个大对象的代价非常高昂。</li>
</ol>
<p><strong>并发整理算法的实现：</strong>ZGC用到了读屏障和染色指针技术。染色指针是一种直接将少量额外的信息存储在指针上的技术。</p>
<p><strong>染色指针的三大优势：</strong></p>
<ol>
<li>染色指针可以使得一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理。</li>
<li>染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量，设置内存屏障，尤其是写屏障的目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然就可以省去一些专门的记录操作。</li>
<li>染色指针可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。</li>
</ol>
<h2 id="3-8-实战-内存分配与回收策略"><a href="#3-8-实战-内存分配与回收策略" class="headerlink" title="3.8 实战:内存分配与回收策略"></a>3.8 实战:内存分配与回收策略</h2><p>Java技术体系的自动内存管理，最根本的目标是自动化解决两个问题：<strong>自动给对象分配内存</strong>和 <strong>自动回收分配给对象的内存</strong></p>
<h3 id="3-8-1-对象优先在Eden分配"><a href="#3-8-1-对象优先在Eden分配" class="headerlink" title="3.8.1 对象优先在Eden分配"></a>3.8.1 对象优先在Eden分配</h3><p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/%E6%88%AA%E5%9B%BE.png" alt="截图"></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>-Xms</td>
<td>初始堆大小</td>
</tr>
<tr>
<td>-Xmx</td>
<td>最大堆大小</td>
</tr>
<tr>
<td>-XX:NewSize&#x3D;n</td>
<td>设置年轻代大小</td>
</tr>
<tr>
<td>-XX:NewRatio&#x3D;n</td>
<td>设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1&#x2F;4</td>
</tr>
<tr>
<td>-XX:SurvivorRatio&#x3D;n</td>
<td>年轻代中Eden区与两个Survivor区的比值。注意<strong>Survivor区</strong>有两个。如：3，表示Eden：Survivor&#x3D;3：2，一个Survivor区占整个年轻代的1&#x2F;5</td>
</tr>
<tr>
<td>-XX:MaxPermSize&#x3D;n</td>
<td>设置持久代大小</td>
</tr>
<tr>
<td>-Xmn2G</td>
<td>设置年轻代大小为2G。</td>
</tr>
<tr>
<td>-XX:PermSize</td>
<td>设置非堆内存初始值，默认是物理内存的1&#x2F;64；</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211015104854948.png" alt="image-20211015104854948"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 内存分配与回收策略;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:左泽林</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>:日期:2021-09-29-时间:21:06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@message</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo3_7</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] allocation1,allocation2,allocation3,allocation4;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们可以看到对象优先在新生代分配，新生代内存已满了之后，会分配在老年代里面</strong></p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211015105628198.png" alt="image-20211015105628198"></p>
<h3 id="3-8-2-大对象直接进入老年代"><a href="#3-8-2-大对象直接进入老年代" class="headerlink" title="3.8.2 大对象直接进入老年代"></a>3.8.2 大对象直接进入老年代</h3><p>大对象就是指需要大量连续内存空间的Java对象，最典型的大对象便是那种很长的字符串，或者元素数量很庞大的数组，本节例子中的byte[]数组就是典型的大对象。<strong>比遇到大对象更恐怖的就是遇到一个朝生夕灭的‘短命大对象’</strong>，我们写程序的时候需要避免。除此之外，大对象往往会触发内存分配，来进行分配他们，这就意味着高额的内存复制开销。</p>
<p>设置参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-verbose:gc</span><br><span class="line">-Xms20M</span><br><span class="line">-Xmx20M</span><br><span class="line">-Xmn10M</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:SurvivorRatio=<span class="number">8</span></span><br><span class="line">-XX:PretenureSizeThreshold=<span class="number">3145728</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo3_8</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] allocation;</span><br><span class="line">        allocation = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">9</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分配的数据会直接分配到老年代。</p>
<h3 id="3-8-3-长期存活的对象进入老年代"><a href="#3-8-3-长期存活的对象进入老年代" class="headerlink" title="3.8.3 长期存活的对象进入老年代"></a>3.8.3 长期存活的对象进入老年代</h3><p>对象分配新生代和老年代的分配规则：</p>
<p>为做到这点，虚拟机给每个对象定义了一个对象年龄(Age) 计数器，存储在对象头中(详见第2章)。对象通常在Eden区里诞生，<strong>如果经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象年龄设为1岁</strong>。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度(<strong>默认为15</strong>)，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数&#x3D;&#x3D;-XX:MaxTenuringThreshold&#x3D;&#x3D;设置。</p>
<h3 id="3-8-4-动态对象年龄判定"><a href="#3-8-4-动态对象年龄判定" class="headerlink" title="3.8.4 动态对象年龄判定"></a>3.8.4 动态对象年龄判定</h3><p>HotSpot虚拟机并不是永远要求对象的年龄必须达到&#x3D;&#x3D;-XX: MaxTenuringThreshold&#x3D;&#x3D;才能晋升老年代，<strong>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半</strong>，年龄大于或等于该年龄的对象就可以直接进入老年代。</p>
<h3 id="3-8-5-空间分配担保"><a href="#3-8-5-空间分配担保" class="headerlink" title="3.8.5 空间分配担保"></a>3.8.5 空间分配担保</h3><p>在发生Minor GC之前，虚拟机必须先检查<strong>老年代最大可用的连续空间是否大于新生代所有对象总空间</strong>，如果这个条件成立，那这一次Minor GC可以确保是安全的。</p>
<p>如果不成立，则虚拟机会先查看-XX: HandlePromotionFailure参数的设置值是否允许担保失败( Handle Promotion Failure) ;</p>
<p>如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小。</p>
<p>​	如果大于，将尝试进行一次M inor GC，尽管这次M inor GC是有风险的;</p>
<p>​	如果小于，或者-XX:HandlePromotionF ailure设置不允许冒险，那这时就要改为进行一次Full GC。</p>
<h1 id="4-虚拟机性能监控、故障处理工具"><a href="#4-虚拟机性能监控、故障处理工具" class="headerlink" title="4.虚拟机性能监控、故障处理工具"></a>4.虚拟机性能监控、故障处理工具</h1><h2 id="4-2-基础故障工具"><a href="#4-2-基础故障工具" class="headerlink" title="4.2 基础故障工具"></a>4.2 基础故障工具</h2><p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211015114755870.png" alt="image-20211015114755870"></p>
<p><strong>这里主要介绍监视虚拟机运行状态和进行故障处理的工具</strong></p>
<h3 id="4-2-1-jsp-虚拟机进程状况工具"><a href="#4-2-1-jsp-虚拟机进程状况工具" class="headerlink" title="4.2.1 jsp:虚拟机进程状况工具"></a>4.2.1 jsp:虚拟机进程状况工具</h3><p>jsp命令格式：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jsp [options] [hostid]</span><br></pre></td></tr></table></figure>

<p><strong>jps远程查询虚拟机进程状态</strong></p>
<h3 id="4-2-2-jstat-虚拟机统计信息监视工具"><a href="#4-2-2-jstat-虚拟机统计信息监视工具" class="headerlink" title="4.2.2 jstat:虚拟机统计信息监视工具"></a>4.2.2 jstat:虚拟机统计信息监视工具</h3><p>jstat命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat [option vmid [interval [s|ms] [count]]]</span><br></pre></td></tr></table></figure>

<p>option:选项</p>
<p>vmid：进程号</p>
<p>interval 查询间隔时间</p>
<p>count	查询次数</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211015120000555.png" alt="image-20211015120000555"></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">user</span>&gt;<span class="title">jstat</span> -<span class="title">gcutil</span> 14108</span></span><br><span class="line"><span class="function">  <span class="title">S0</span>     <span class="title">S1</span>     <span class="title">E</span>      <span class="title">O</span>      <span class="title">M</span>     <span class="title">CCS</span>    <span class="title">YGC</span>     <span class="title">YGCT</span>    <span class="title">FGC</span>    <span class="title">FGCT</span>     <span class="title">GCT</span></span></span><br><span class="line"><span class="function">  0.00   0.00  11.76  49.79  95.30  88.05    295    1.663     1    1.156    2.819</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">E 新生代百分比11.76%</span><br><span class="line">s0和s1 代表两个survivor区，我们可以看到里面是空的</span><br><span class="line">O 老年代，使用了49.79%</span><br><span class="line">P 永久代</span><br><span class="line">YGC MinorGC使用了295次</span><br><span class="line">FGC FullFC使用了1次 </span><br><span class="line">FGCT 表示FullGC的总耗时</span><br><span class="line">GCT 所有GC的耗时</span><br></pre></td></tr></table></figure>

<h3 id="4-2-3-jinfo-Java配置信息工具"><a href="#4-2-3-jinfo-Java配置信息工具" class="headerlink" title="4.2.3 jinfo:Java配置信息工具"></a>4.2.3 jinfo:Java配置信息工具</h3><p>jinfo的作用是实时查看和调整虚拟机的各项参数。</p>
<h3 id="4-2-4-jmap-Java内存映像工具"><a href="#4-2-4-jmap-Java内存映像工具" class="headerlink" title="4.2.4 jmap:Java内存映像工具"></a>4.2.4 jmap:Java内存映像工具</h3><p>jmap命令用于生成堆转储快照。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap [option] vmid</span><br></pre></td></tr></table></figure>

<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211015121904801.png" alt="image-20211015121904801"></p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=eclipse.bin <span class="number">3500</span></span><br></pre></td></tr></table></figure>



<h3 id="4-2-5-jhat-虚拟机堆转储快照分析工具"><a href="#4-2-5-jhat-虚拟机堆转储快照分析工具" class="headerlink" title="4.2.5 jhat:虚拟机堆转储快照分析工具"></a>4.2.5 jhat:虚拟机堆转储快照分析工具</h3><p>JD提功jhat命令与jmap搭配使用，来分析jmap生成的堆转储快照。</p>
<h3 id="4-2-6-jstack-Java堆栈跟踪工具"><a href="#4-2-6-jstack-Java堆栈跟踪工具" class="headerlink" title="4.2.6 jstack:Java堆栈跟踪工具"></a>4.2.6 jstack:Java堆栈跟踪工具</h3><p>jstack命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的目的通常是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间挂起等，都是导致线程长时间停顿的常见原因。线程出现停顿时通过jstack来查看各个线程的调用堆栈，就可以获知没有响应的线程到底在后台做些什么事情，或者等待着什么资源。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack [option] vmid</span><br></pre></td></tr></table></figure>

<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211015141020626.png" alt="image-20211015141020626"></p>
<h2 id="4-3-可视化故障处理工具"><a href="#4-3-可视化故障处理工具" class="headerlink" title="4.3 可视化故障处理工具"></a>4.3 可视化故障处理工具</h2><h3 id="4-3-1-JHSDB-基于服务性代理的调试工具"><a href="#4-3-1-JHSDB-基于服务性代理的调试工具" class="headerlink" title="4.3.1 JHSDB:基于服务性代理的调试工具"></a>4.3.1 JHSDB:基于服务性代理的调试工具</h3><p>JHSDB是一款基于服务性代理实现的进程外调试工具。</p>
<p>服务性代理是HotSpot虚拟机中一组用于映射Java虚拟机运行信息的、主要基于Java语言实现的API集合。</p>
<h3 id="4-3-2-JConsole-Java监视与管理控制台"><a href="#4-3-2-JConsole-Java监视与管理控制台" class="headerlink" title="4.3.2 JConsole:Java监视与管理控制台"></a>4.3.2 JConsole:Java监视与管理控制台</h3><p>JConsole是一款基于JMX的可视化监视、管理工具。</p>
<p><strong>主要功能</strong>：通过JMX的M Bean (M anaged Bean) 对<strong>系统进行信息收集和参数动态调整</strong>。JMX是一种开放性的技术，不仅可以用在虚拟机本身的管理上，还可以运行于虚拟机上的软件中，典型的如中间件大多也基于JMX来实现管理与监控。虚拟机对JMX。</p>
<p><strong>开启方式</strong></p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211015142440820.png" alt="image-20211015142440820"></p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211015142558790.png" alt="image-20211015142558790"></p>
<hr>
<p><strong>2.内存监控</strong></p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211015143036532.png" alt="image-20211015143036532"></p>
<hr>
<p><strong>3.线程监控</strong></p>
<p>可以检测死锁</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211015143219891.png" alt="image-20211015143219891"></p>
<h3 id="4-3-3-VisualVM-多合-故障处理工具"><a href="#4-3-3-VisualVM-多合-故障处理工具" class="headerlink" title="4.3.3 VisualVM:多合-故障处理工具"></a>4.3.3 VisualVM:多合-故障处理工具</h3><p>VisuaIVM ( All-in-One Java Troubleshooting Tool)是功能最强大的<strong>运行监视和故障处理</strong>程序之一，曾经在很长一段时间内是Oracle官方主力发展的虚拟机故障处理工具。VisualVM还有一个很大的优点:不需要被监视的程序基于特殊Agent去运行，因此它的通用性很强，对应用程序实际性能的影响也较小，使得它可以直接应用在生产环境中。这个优点是JProfiler、YourKit等 工具无法与之媲美的。</p>
<p>功能：</p>
<ul>
<li>显示虚拟机进程以及进程的配置、环境信息(jps、 jinfo) 。</li>
<li>监视应用程序的处理器、垃圾收集、堆、方法区以及线程的信息(jstat、 jstack) 。</li>
<li>dump以及分析堆转储快照(jmap、 jhat )。</li>
<li>方法级的程序运行性能分析，找出被调用最多、运行时间最长的方法。</li>
<li>离线程序快照:收集程序的运行时配置、线程dump、内存dump等信息建立一个<strong>快照</strong>，可以将快照发送开发者处进行Bug反馈。</li>
<li>其他插件带来的无限可能性。</li>
</ul>
<hr>
<p><strong>分析程序性能</strong></p>
<p>使用profile来进行分析。</p>
<hr>
<p><strong>BTrace</strong></p>
<p>BTrace是一个很神奇的VisualVM插件，它本身也是一个可运行的独立程序。BTrace的作用是在不中断目标程序运行的前提下，通过HotSpot 虚拟机的Instrument功能[4动态加入原本并不存在的调试代码。这项功能对实际生产中的程序很有意义:如当程序出现问题时，排查错误的-些必要信息时(譬如方法参数、返回值等)，在开发时并没有打印到日志之中以至于不得不停掉服务时，都可以通<br>过调试增量来加入日志代码以解决问题。</p>
<h3 id="4-3-4-Java-Misssion-Control-可持续在线的监控工具"><a href="#4-3-4-Java-Misssion-Control-可持续在线的监控工具" class="headerlink" title="4.3.4 Java Misssion Control:可持续在线的监控工具"></a>4.3.4 Java Misssion Control:可持续在线的监控工具</h3><h1 id="5-调优案例分析与实战"><a href="#5-调优案例分析与实战" class="headerlink" title="5.调优案例分析与实战"></a>5.调优案例分析与实战</h1><h2 id="5-2-案例分析"><a href="#5-2-案例分析" class="headerlink" title="5.2 案例分析"></a>5.2 案例分析</h2><h3 id="5-2-1-大内存硬件上的程序部署策略"><a href="#5-2-1-大内存硬件上的程序部署策略" class="headerlink" title="5.2.1 大内存硬件上的程序部署策略"></a>5.2.1 大内存硬件上的程序部署策略</h3><p>这是笔者很久之前处理过的一个案例，但今天仍然具有代表性。一个15万PV&#x2F;日左右的在线文档类型网站最近更换了硬件系统，服务器的硬件为四路志强处理器、16GB物理内存，操作系统为64位CentOS5.4，Resin作为Web服务器。整个服务器暂时没有部署别的应用，所有硬件资源都可以提供给这访问量并不算太大的文档网站使用。软件版本选用的是64位的JDK5，管理员启用了一个虛拟机实例，使用-Xmx和-Xms参数将Java堆大小固定在12GB。使用一段时间后发现服务器的运行效果十分不理想，网站经常不定期出现长时间失去响应。</p>
<hr>
<p><strong>原因</strong>：垃圾收集器停顿所导致的。默认使用的是吞吐量优先收集器，回收12GB的Java堆，一次FullGC的停顿时间就高达14秒。</p>
<hr>
<p><strong>解决方案：</strong></p>
<p>目前单体应用在较大内存的硬件上主要有两种部署方式</p>
<ol>
<li>通过一个单独的Java虚拟机实例来管理大量的Java堆内存。</li>
<li>同时使用若干个Java虚拟机，建立逻辑集群来利用硬件资源。</li>
</ol>
<p><strong>其次</strong>:可以在深夜执行定时任务的方式触发full GC甚至是重新启动应用服务器来保持内存可用空间在一个稳定水平。</p>
<p>控制Full GC频率的关键是老年代的相对稳定，这主要取决于应用中绝大多数对象能否符合“朝生夕灭”的原则，即大多数对象的生存时间不应当太长，尤其是不能有成批量的、长生存时间的大对象产生，这样才能保障老年代空间的稳定。</p>
<p><strong>现实生活中：</strong>B&#x2F;S形式的应用里，多数对象的生存周期都应该是请求级或者页面级的，会话级和全局级的长生命对象相对较少。</p>
<h3 id="5-2-2-集群间同步导致的内存溢出"><a href="#5-2-2-集群间同步导致的内存溢出" class="headerlink" title="5.2.2 集群间同步导致的内存溢出"></a>5.2.2 集群间同步导致的内存溢出</h3><p>集群的优点可以均衡并发处理，以及合理利用服务器资源。缺点就是会使用一部分开销，以及数据冗余。</p>
<h3 id="5-2-3-堆外内存导致的溢出错误"><a href="#5-2-3-堆外内存导致的溢出错误" class="headerlink" title="5.2.3 堆外内存导致的溢出错误"></a>5.2.3 堆外内存导致的溢出错误</h3><p>直接内存不能像新生代、老年代那样，发现空间不足了就主动通知收集器进行垃圾回收，它只能等待老年代满后Full GC出现后，“顺便”帮它清理掉内存的废弃对象。否则就不得不一直等到拋出内存溢出异常时，才进行清理。</p>
<p>从实践经验的角度出发，在处理小内存或者32位的应用问题时，除了Java堆和方法区之外，我们注意到下面这些区域还会占用较多的内存，这里所有的内存总和受到操作系统进程最大内存的限制:</p>
<p>直接内存:可通过-XX: M axDirectM emory Size调整大小，内存不足时拋出OutOf-M emory Error或者OutOfMemoryError: Direct buffer memory。</p>
<p>线程堆栈:可通过-Xss调整大小，内存不足时拋出StackOverflowError (如果线程请求的栈深度大于虚拟机所允许的深度)或者OutOfM emory Error (如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存)。</p>
<p>Socket缓存区:每个Socket连接都Receive和Send两个缓存区，分别占大约37KB和25KB内存，连接多的话这块内存占用也比较可观。如果无法分配，可能会抛出IOException: Too many open files 异常。</p>
<p>JNI代码:如果代码中使用了JNI调用本地库，那本地库使用的内存也不在堆中，而是占用Java虛拟机的本地方法栈和本地内存的。</p>
<p>虚拟机和垃圾收集器:虛拟机、垃圾收集器的工作也是要消耗一定数量的内存的。</p>
<h3 id="5-2-4-外部命令导致系统缓慢"><a href="#5-2-4-外部命令导致系统缓慢" class="headerlink" title="5.2.4 外部命令导致系统缓慢"></a>5.2.4 外部命令导致系统缓慢</h3><p>用户根据建议去掉这个Shell脚本执行的语句，改为使用Java的API去获取这些信息后，系统很快恢复了正常。</p>
<h3 id="5-2-5-服务器虚拟机进程崩溃"><a href="#5-2-5-服务器虚拟机进程崩溃" class="headerlink" title="5.2.5 服务器虚拟机进程崩溃"></a>5.2.5 服务器虚拟机进程崩溃</h3><p><strong>原因：</strong>MIS系统的用户多，待办事项变化很快，为了不被0A系统速度拖累，使用了异步的方式调用Web服务，但由于两边服务速度的完全不对等，时间越长就累积了越多Web服务没有调用完成，导致在等待的线程和Socket连接越来越多，最终超过虚拟机的承受能力后导致虛拟机进程崩溃。</p>
<p><strong>解决方案：</strong>通知OA门户方修复无法使用的集成接口，并将异步调用改为生产者&#x2F;消费者模式的消息队列实现后，系统恢复正常。</p>
<h3 id="5-2-6-不恰当数据结构导致内存占用过大"><a href="#5-2-6-不恰当数据结构导致内存占用过大" class="headerlink" title="5.2.6 不恰当数据结构导致内存占用过大"></a>5.2.6 不恰当数据结构导致内存占用过大</h3><p>我们具体分析一-下HashM ap空间效率，在HashM ap&lt;Long，Long结 构中，只 有Key和Value所存放的两个长整型数据是有效数据，共16字节(2x8字节)。这两个长整型数据包装成java.langLong对象之后，就分别具有8字节的M ark Word、 8字节的Klass指针，再加8字节存储数据的long值。 然后这2个Long对象组成Map .Entry之后，又多了16字节的对象头，然后一个8字节的next字段和4字节的int型的hash字段，为了对齐，还必须添加4字节的空白填充，最后还有HashM ap中对这个Entry的8字节的引用，这样增加两个长整型数字，实际耗费的内存为( ong(24byte)x 2)+Fntry(32by te)+HashMap Ref(8byte)&#x3D;88byte，空间效率为有效数据除以全部内存空间，即16字节&#x2F;88字节&#x3D;18%，这确实太低了。</p>
<h3 id="5-2-7-由Windows虚拟内存导致的长时间停顿"><a href="#5-2-7-由Windows虚拟内存导致的长时间停顿" class="headerlink" title="5.2.7 由Windows虚拟内存导致的长时间停顿"></a>5.2.7 由Windows虚拟内存导致的长时间停顿</h3><h3 id="5-2-8-由安全点导致长时间停顿"><a href="#5-2-8-由安全点导致长时间停顿" class="headerlink" title="5.2.8 由安全点导致长时间停顿"></a>5.2.8 由安全点导致长时间停顿</h3><h1 id="6-字节码"><a href="#6-字节码" class="headerlink" title="6.字节码"></a>6.字节码</h1><h3 id="6-3-7-属性表集合"><a href="#6-3-7-属性表集合" class="headerlink" title="6.3.7 属性表集合"></a>6.3.7 属性表集合</h3><p>一共有14个属性。</p>
<h2 id="6-4-字节码指令简介"><a href="#6-4-字节码指令简介" class="headerlink" title="6.4 字节码指令简介"></a>6.4 字节码指令简介</h2><h1 id="7-虚拟机类加载机制"><a href="#7-虚拟机类加载机制" class="headerlink" title="7.虚拟机类加载机制"></a>7.虚拟机类加载机制</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。</p>
<p>Java天生可以动态扩展的语言特性就是依赖运行期间动态加载和动态链接这个特点实现的。</p>
<h2 id="7-2-类加载的时机"><a href="#7-2-类加载的时机" class="headerlink" title="7.2 类加载的时机"></a>7.2 类加载的时机</h2><p>一个类型从被加载到虚拟机内存中开始，到卸载为止，它的整个生命周期将会经过 <strong>加载、验证、准备、解析、初始化、使用、卸载七个阶段</strong>。其中 <strong>验证、准备、解析</strong>三个部分统称为 <strong>连接</strong></p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211008200754644.png" alt="image-20211008200754644"></p>
<p>加载、验证、准备、初始化和卸载这五个步骤是不变的，但是解析却不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行是的绑定特性(动态绑定或者晚期绑定)。<strong>解析时间具体由虚拟机自己掌握</strong></p>
<p><strong>《Java虚拟机规范》严格规定有且只有六种情况必需对类进行初始化</strong>。</p>
<ol>
<li>遇到new、getstatic、 putstatic或invokestatic这 四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有:<ol>
<li>使用new关键字实例化对象的时候。</li>
<li>读取或设置一个类型的静态字段(被fnal修饰、已在编译期把结果放入常量池的静态字段除外)的时候。</li>
<li>调用一个类型的静态方法的时候。</li>
</ol>
</li>
<li>使用java. langeflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类( 包含main)方法的那个类)，虚拟机会先初始化这个主类。</li>
<li>当使用JDK 7新加入的动态语言支持时，如果- - -个java. lang invoke. MethodHandle实例最后的解析结果为REF_ getStatic、 REF_ putStatic、 REF_ <em>invokeStatic、 REF</em> newInvokeSpecial四种 类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li>
<li>当一个接口中定义了JDK 8新加入的默认方法(被default关键字修饰的接口方法)时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>
</ol>
<hr>
<p><strong>简化：</strong>1.使用new关键字，调用类中的静态属性，调用类中到的静态方法 2.反射调用一个类 3.子类进行初始化 4.类为启动类 5.类的初始化导致实现的接口初始化 6.动态语言</p>
<h2 id="7-3-类加载过程"><a href="#7-3-类加载过程" class="headerlink" title="7.3 类加载过程"></a>7.3 类加载过程</h2><h3 id="7-3-1-加载"><a href="#7-3-1-加载" class="headerlink" title="7.3.1 加载"></a>7.3.1 加载</h3><p><strong>加载是整个类加载的一个过程。</strong>在加载阶段，Java虚拟机需要完成三件事情：</p>
<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口（生成在方法区，相当于模板）。</li>
</ul>
<blockquote>
<p>因为Java虚拟机对着三点要求不是特别具体，没有指明二进制字节流必须得从某个Class文件中获取，确切的说根本没有说从哪里获取，怎么获取，所以开发人员玩出了各种花样。</p>
</blockquote>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211009162037324.png" alt="image-20211009162037324"></p>
<hr>
<p><strong>数组类</strong></p>
<p>对于数组类而言，情况就有所不同，<strong>数组类本身不通过类加载器创建</strong>，它是由Java虛拟机直接在内存中动态构造出来的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型 (ElementType,指的是数组去掉所有维度的类型) 最终还是要靠类加载器来完成加载，一个数组类(下面简称为C)创建过程遵循以下规则:</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211009162333014.png" alt="image-20211009162333014"></p>
<hr>
<p><strong>总结</strong></p>
<p>加载阶段与连接阶段的部分动作(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部分，这两个阶段的开始时间仍然保持着固定的先后顺序。</p>
<h3 id="7-3-2-验证"><a href="#7-3-2-验证" class="headerlink" title="7.3.2 验证"></a>7.3.2 验证</h3><p><strong>目的是确保Class文件的字节流包含的信息符和《Java虚拟机规范》的全部约束要求，保证信息被当作代码运行后不会危害虚拟机自身安全。</strong></p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211009163752626.png" alt="image-20211009163752626"></p>
<hr>
<p>验证过程：<strong>文件格式验证、元数据验证、字节码验证和符号引用验证。</strong></p>
<p><strong>1.文件格式验证</strong></p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211009164128513.png" alt="image-20211009164128513"></p>
<p><strong>2.元数据验证</strong></p>
<p><strong>元数据：</strong>元数据是指用来描述数据的数据，更通俗一点，就是描述代码间关系，或者代码与其他资源(例如数据库表)之间内在联系的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一， 元数据以标签的形式存在于Java代码中。</span><br><span class="line"></span><br><span class="line">第二， 元数据描述的信息是类型安全的，即元数据内部的字段都是有明确类型的。</span><br><span class="line"></span><br><span class="line">第三， 元数据需要编译器之外的工具额外的处理用来生成其它的程序部件。</span><br><span class="line"></span><br><span class="line">第四， 元数据可以只存在于Java源代码级别，也可以存在于编译之后的Class文件内部。</span><br></pre></td></tr></table></figure>

<p>　JDK5.0出来后，java语言中就有了四种类型（TYPE），即类(class)、枚举(enum)、接口(interface)和注解(@interface)，它们是处在同一级别的。java就是通过注解来表示元数据的。</p>
<p>主要目的是对类的元数据信息进行语义校验，保证不存在与《Java语言规范》定义相勃的元数据信息。</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211009164223908.png" alt="image-20211009164223908"></p>
<p><strong>3.字节码验证</strong></p>
<p>主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211009164310587.png" alt="image-20211009164310587"></p>
<p><strong>4.符号引用验证</strong></p>
<p>这个动作将会发生在连接的第三个阶段——解析。</p>
<p>符号引用验证通俗的来说，就是判断该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211009164813337.png" alt="image-20211009164813337"></p>
<hr>
<p><strong>总结</strong></p>
<p>验证阶段对于虚拟机的类加载机制来说，是一个非常重要的、但却不是必须要执行的阶段，因为验证阶段只有通过或者不通过的差别，只要通过了验证，其后就对程序运行期没有任何影响了。如果程序运行的全部代码(包括自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码)都已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用-Xverify: none参 数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<h3 id="7-3-3-准备"><a href="#7-3-3-准备" class="headerlink" title="7.3.3 准备"></a>7.3.3 准备</h3><p><strong>准备阶段是正式为类中定义(即静态变量，被static修饰的变量)分配内存并设置类变量初始值的阶段。</strong></p>
<h3 id="7-3-4-解析"><a href="#7-3-4-解析" class="headerlink" title="7.3.4 解析"></a>7.3.4 解析</h3><p><strong>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程</strong></p>
<hr>
<p><strong>符号引用和直接引用</strong></p>
<p>符号引用：</p>
<ul>
<li>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</li>
</ul>
<p>直接引用：</p>
<ul>
<li>直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。</li>
</ul>
<hr>
<p><strong>解析动作主要针对</strong>：类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行。</p>
<h3 id="7-3-5-初始化"><a href="#7-3-5-初始化" class="headerlink" title="7.3.5 初始化"></a>7.3.5 初始化</h3><p><strong>直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序。</strong></p>
<p>初始化含义：根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。也可以理解初始化阶段就是执行类构造器<clinit>()方法的过程。</p>
<hr>
<p><strong>Clinit方法</strong></p>
<h2 id="7-4-类加载器"><a href="#7-4-类加载器" class="headerlink" title="7.4 类加载器"></a>7.4 类加载器</h2><p>Java虛拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“类加载器”(Class Loader)。</p>
<h3 id="7-4-1-类与类加载器"><a href="#7-4-1-类与类加载器" class="headerlink" title="7.4.1 类与类加载器"></a>7.4.1 类与类加载器</h3><p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都有一个独立的类名空间。</p>
<h3 id="7-4-2-双亲委派模型"><a href="#7-4-2-双亲委派模型" class="headerlink" title="7.4.2 双亲委派模型"></a>7.4.2 双亲委派模型</h3><p>自JDK1.2开始以来，Java一直保持着三层类加载器、双亲委派的类加载架构。</p>
<hr>
<p><strong>三层类加载器</strong></p>
<blockquote>
<p>启动类加载器(Bootstarp Class Loader)</p>
</blockquote>
<p>这个类加载器负责加载存放在<JAVA_HOME>\lib目录下，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的(按照文件名识别.jar)类库加载到虚拟机内存中。</p>
<p>用户也可以自己加载，需要委派给引导类加载器去处理。</p>
<blockquote>
<p>扩展类加载器(Extension Class Loader)</p>
</blockquote>
<p>它负责加载<Java_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。</p>
<p>由于扩展类是由Java代码实现的，程序媛可以直接在程序中使用扩展类加载器来加载Class文件。</p>
<blockquote>
<p>应用程序类加载器(Application Class Loader)</p>
</blockquote>
<p>应用程序是ClassLoader类中的getSystem-ClassLoader()方法的返回值，所以有些场合也称它为：系统类加载器。</p>
<p>它负责加载用户类路径(ClassPath)上所有的类库，开发者同样可以直接在代码中使用这个类加载器。</p>
<hr>
<p><strong>双亲委派模型</strong></p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211009191443157.png" alt="image-20211009191443157"></p>
<p>各种类加载器之间的层次关系被称为类加载器的“双亲委派模型”。</p>
<p><strong>工作过程</strong></p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211009191627202.png" alt="image-20211009191627202"></p>
<p><strong>好处</strong></p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211009191650170.png" alt="image-20211009191650170"></p>
<p><strong>双亲委派方法的实现</strong></p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211009191713165.png" alt="image-20211009191713165"></p>
<h3 id="7-4-3-破坏双亲委派模型"><a href="#7-4-3-破坏双亲委派模型" class="headerlink" title="7.4.3 破坏双亲委派模型"></a>7.4.3 破坏双亲委派模型</h3><p>双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。在Java世界中大部分类加载器都遵循这个模型，但也有例外的情况，在模块化(Java9)出现之前，双亲委派模型主要出现过3次较大规模“被破坏”的情况。</p>
<hr>
<p><strong>第一次破坏</strong></p>
<p>为了避免loadClass()被子类覆盖的可能性，于是在JDK1.2之后的Java.lang.ClassLoader中新添加一个protected方法findClass(),并引导用户编写类的加载逻辑时尽可能的去重写这个方法，而不是在ClassLoader()中编写代码。</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211009193953312.png" alt="image-20211009193953312"></p>
<hr>
<p><strong>第二次破坏</strong></p>
<p>原因是因为这个“双亲委派功能”自身的缺陷导致的。</p>
<p><strong>双亲委派很好的解决了各个类加载器协作时基础类型的一致性问题(越基础的类由越上层的加载器进行加载)，但是我基础类型又要回调用户的代码怎么办？</strong></p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211009194558225.png" alt="image-20211009194558225"></p>
<hr>
<p><strong>第三次破坏</strong></p>
<p>双亲委派机制的第三次破坏是由于用户对程序动态性的追求而导致的：<strong>代码热替换、模块热部署</strong></p>
<p>这里比较特点的就是IBM的OSGI。</p>
<p><strong>OSGI</strong>实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块(OSGI中称为Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。</p>
<p>收到类加载请求时，OSGI将按照下面的顺序进行类搜索：</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211009195309823.png" alt="image-20211009195309823"></p>
<h2 id="7-5-Java模块化系统"><a href="#7-5-Java模块化系统" class="headerlink" title="7.5 Java模块化系统"></a>7.5 Java模块化系统</h2><p>实现Java模块化的关键目标——可配置的封装隔离机制。</p>
<hr>
<p><strong>可配置的封装隔离机制</strong></p>
<p>解决问题1：</p>
<p>JDK9之前基于类路径(ClassPath)来查找依赖的可靠性问题。</p>
<p>解决问题2：</p>
<p>可配置的封装隔离机制还解决了原来类路径上跨JAR文件的public类型的可访问性问题。</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211010182005251.png" alt="image-20211010182005251"></p>
<hr>
<h3 id="7-5-2-模块化下的类加载器"><a href="#7-5-2-模块化下的类加载器" class="headerlink" title="7.5.2 模块化下的类加载器"></a>7.5.2 模块化下的类加载器</h3><p>模块系统最终还是影响到了类加载器。</p>
<ol>
<li>扩展类加载器被平台类加载器取代，顺理成章的变动，毕竟要推动模块化的实现。</li>
<li>平台类加载器和应用程序加载器都不再派生自java.net.URLClassLoader，启动类加载器、平台类加载器、应用程序类加载器都继承jdk.internal.loader.BuiltinClassLoader。</li>
<li>当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</li>
</ol>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211011172839155.png" alt="image-20211011172839155"></p>
<h1 id="8-虚拟机字节码执行引擎"><a href="#8-虚拟机字节码执行引擎" class="headerlink" title="8.虚拟机字节码执行引擎"></a>8.虚拟机字节码执行引擎</h1><h2 id="8-1概述"><a href="#8-1概述" class="headerlink" title="8.1概述"></a>8.1概述</h2><p>Java虚拟机执行引擎的功能：将输入的字节码二进制流编译，处理过程是字节码解析执行的等效过程，输出的是执行结果。</p>
<h2 id="8-2-运行时栈帧结构"><a href="#8-2-运行时栈帧结构" class="headerlink" title="8.2 运行时栈帧结构"></a>8.2 运行时栈帧结构</h2><p><strong>Java虚拟机已方法作为最基本的执行单位。</strong></p>
<hr>
<p><strong>栈帧：是支持Java虚拟机进行方法调用和方法执行背后的数据结构。</strong></p>
<p>栈帧存储了方法的 <strong>局部变量表、操作数栈、动态连接和放回地址等信息。</strong></p>
<p>每一个方法的调用开始和执行结束，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p>
<hr>
<p><strong>栈帧内存</strong></p>
<p>一个栈桢需要分配多少内存，并不会受程序运行期变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式。</p>
<hr>
<p><strong>栈帧运行</strong></p>
<p>对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是运行的，只有位于栈顶的栈帧才是生效的，其被称为“当前栈帧”，与这个栈帧所关联的方法称为“当前方法”。</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211011194252335.png" alt="image-20211011194252335"></p>
<h3 id="8-2-1-局部变量表"><a href="#8-2-1-局部变量表" class="headerlink" title="8.2.1 局部变量表"></a>8.2.1 局部变量表</h3><p><strong>局部变量表是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量</strong></p>
<hr>
<p><strong>线程安全</strong></p>
<p>由于局部变量表是建立在线程堆栈中的，属于线程私有的数据，无论读写两个连续的变量槽是否为原子操作，都不会引起数据竞争和线程安全问题。</p>
<hr>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211011194821908.png" alt="image-20211011194821908"></p>
<h3 id="8-2-2-操作数栈"><a href="#8-2-2-操作数栈" class="headerlink" title="8.2.2 操作数栈"></a>8.2.2 操作数栈</h3><p><strong>操作数栈也常被称为操作栈，它是一个后入先出栈</strong></p>
<hr>
<p><strong>功能</strong></p>
<p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211011195101549.png" alt="image-20211011195101549"></p>
<hr>
<p><strong>数据共享</strong></p>
<p>两个不同的栈帧作为不同方法的虚拟机栈元素，是完全相互独立的。但虚拟机的实现里都会进一步优化处理，令两个栈桢重叠，可以节约一部分空间，并且共用一部分数据。</p>
<h3 id="8-2-3-动态连接"><a href="#8-2-3-动态连接" class="headerlink" title="8.2.3 动态连接"></a>8.2.3 动态连接</h3><p><strong>每个栈帧都包含一个指向运行时常量池中该栈帧所述方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。</strong></p>
<hr>
<p>字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。这些符号引用一部分会在类<strong>加载</strong>阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析。</p>
<p>另外一部分将在<strong>每一次运行期间都</strong>转化为直接引用，这部分就称为动态连接。关于这两个转化过程的具体过程，将在8.3节中再详细讲解。</p>
<h3 id="8-2-4-方法返回地址"><a href="#8-2-4-方法返回地址" class="headerlink" title="8.2.4 方法返回地址"></a>8.2.4 方法返回地址</h3><p>当一个方法返回后，只有两种方式退出这个方法。</p>
<ol>
<li>执行引擎遇到任意一个方法返回的字节码指令。</li>
<li>方法执行的过程中遇到了异常。</li>
</ol>
<p><strong>无论采用何种退出方式，在方法退出之后，都必须返回到最初方法被调用的位置</strong></p>
<hr>
<p>方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有:<strong>恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等</strong>。笔者这里写的“可能”是由于这是基于概念模型的讨论，只有具体到某一款Java虛 拟机实现，会执行哪些操作才能确定下来。</p>
<h3 id="8-2-5-附加信息"><a href="#8-2-5-附加信息" class="headerlink" title="8.2.5 附加信息"></a>8.2.5 附加信息</h3><p>《Java虚拟机规范》允许虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试、性能收集相关的信息。</p>
<h2 id="8-3-方法的调用"><a href="#8-3-方法的调用" class="headerlink" title="8.3 方法的调用"></a>8.3 方法的调用</h2><p>方法调用阶段唯一的任务就是确定被调用方法的版本(即调用哪一个方法)，暂时还未涉及方法内部的具体运行过程。</p>
<h3 id="8-3-1-解析"><a href="#8-3-1-解析" class="headerlink" title="8.3.1 解析"></a>8.3.1 解析</h3><p><strong>调用目标在程序代码写好、编译器进行编译的那一刻就已经确定下来了，这类方法的调用被称为解析。</strong></p>
<hr>
<p>适合类加载阶段的方法：静态方法和私有方法</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211011201909813.png" alt="image-20211011201909813"></p>
<hr>
<p><strong>五种非虚方法</strong></p>
<p>只要能被<strong>invokestatic和invokespecial</strong>指令调用的方法，都可以在解析阶段中确定唯一的调用版本，Java语言里符合这个条件的方法共有静态方法、私有方法、实例构造器、父类方法4种，再加上被final修饰的方法(尽管它使用invokevirtual指令调用)，这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为“<strong>非虚方法</strong>”(Non-Virtual Method)，与之相反，其他方法就被称为“虚方法”(VirtualMethod)。</p>
<hr>
<p><strong>解析调用是静态的</strong></p>
<p><strong>解析调用一定是个静态的过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转变为明确的直接引用，不必延迟到运行期再去完成</strong>。而另一种主要的方法调用形式:分派(Dispatch)调用则要复杂许多，它可能是静态的也可能是动态的，按照分派依据的宗量数可分为单分派和多分派川。这两类分派方式两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派4种分派组合情况，下面我们来看看虚拟机中的方法分派是如何进行的。</p>
<h3 id="8-3-2-分派"><a href="#8-3-2-分派" class="headerlink" title="8.3.2 分派"></a>8.3.2 分派</h3><p>本节讲解的分派调用过程将会揭示多态性特征的一-些最基本的体现，如“重载”和“重写”在Java虚拟机之中是如何实现的。</p>
<h4 id="8-3-2-1-静态分派"><a href="#8-3-2-1-静态分派" class="headerlink" title="8.3.2.1 静态分派"></a>8.3.2.1 静态分派</h4><p><strong>静态分派：</strong></p>
<hr>
<p><strong>案例：</strong></p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211011232531558.png" alt="image-20211011232531558"></p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211011232545719.png" alt="image-20211011232545719"></p>
<p>我们先来看一段代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Human man=<span class="keyword">new</span> <span class="title class_">Man</span>();</span><br></pre></td></tr></table></figure>

<p>我们把上面代码中的<strong>“Human”称为变量的“静态类型”</strong>( Static Type)，或者叫“外观类型”(Apparent Type)，后面的<strong>“Man”则被称为变量的“实际类型”</strong>(Actual Type)或者叫“运行时类型”(Runtime Type)。静态类型和实际类型在程序中都可能会发生变化，区别是<strong>静态类型的变化仅仅在使用时发生</strong>，变量本身的静态类型不会被改变，并且<strong>最终的静态类型是在编译期可知的</strong>；而<strong>实际类型变化的结果在运行期才可确定</strong>，<strong>编译器在编译程序的时候并不知道一个对象的实际类型是什么</strong>。笔者猜想上面这段话读者大概会不太好理解，那不妨通过一段实际例子来解释，譬如有下面的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例类型变化</span></span><br><span class="line"><span class="type">Human</span> <span class="variable">human</span> <span class="operator">=</span> (<span class="keyword">new</span> <span class="title class_">Random</span>()).nextBoolean()?<span class="keyword">new</span> <span class="title class_">Man</span>():<span class="keyword">new</span> <span class="title class_">Woman</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态类型变化</span></span><br><span class="line">sr.sayHello((Man) human)</span><br><span class="line">sr.sayHello((Woman) human)</span><br></pre></td></tr></table></figure>

<p><strong>对象human的实际类型是可变的</strong>，编译期间它完全是个“<strong>薛定谔的人</strong>”，到底是Man还是Woman,必须等到程序运行到这行的时候才能确定。而human的静态类型是Human，也可以在使用时(如say Hello()方法中的强制转型)临时改变这个类型，但这个改变仍是在编译期是可知的，两次sayHello()方法的调用，在编译期完全可以明确转型的是Man还是Woman。</p>
<p>解释清楚了静态类型与实际类型的概念，我们就把话题再转回到代码清单8-6的样例代码中。main()里面的两次say Hello()方法调用，在方法接收者已经确定是对象“sr”的前提下，<strong>使用哪个重载版本，就完全取决于传入参数的数量和数据类型</strong>。代码中故意定义了两个静态类型相同，而实际类型不同的变量，但虚拟机(或者准确地说是编译器)<strong>在重载时是通过参数的静态类型而不是实际类型作为判定依据的</strong>。<strong>由于静态类型在编译期可知，所以在编译阶段，Javac编译器就根据参数的静态类型决定了会使用哪个重载版本</strong>，因此选择了sayHello(Human)作为调用目标，并把这个方法的符号引用写到main(方法里的两条invokevirtual指令的参数中。</p>
<p><strong>所有依赖静态类型来决定方法执行版本的分派动作，都称为静态分派</strong>。静态分派的最典型应用表现就是<strong>方法重载</strong>。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的，这点也是为何一些资料选择把它归入“解析”而不是“分派”的原因。</p>
<p>另外还有一点读者可能比较容易混淆:笔者讲述的解析与分派这两者之间的关系并不是二选一的排他关系，它们是在不同层次上去筛选、确定目标方法的过程。例如前面说过静态方法会在编译期确定、在类加载期就进行解析，而静态方法显然也是可以拥有重载版本的，选择重载版本的过程也是通过静态分派完成的。</p>
<h4 id="8-3-2-2-动态分派"><a href="#8-3-2-2-动态分派" class="headerlink" title="8.3.2.2 动态分派"></a>8.3.2.2 动态分派</h4><p>动态分派与Java语言多态性的另外一个重要体现——重写(Override)有着很密切的关联。</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211011234826453.png" alt="image-20211011234826453"></p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211021001419982.png" alt="image-20211021001419982"></p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211011234944124.png" alt="image-20211011234944124"></p>
<p>根据《Java虚拟机规范》invokevirtual指令的运行时解析过程大致分为以下几步：</p>
<p>1)<strong>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C</strong>。</p>
<p>2)<strong>如果在类型C中找到与常量中的描述符和简单名称都相符的方法</strong>，则进行访问<strong>权限校验</strong>，如果<strong>通过则返回这个方法的直接引用</strong>，<strong>查找过程结束</strong>;<strong>不通过则返回java.lang IlegalAccessError异常</strong>。</p>
<p>3)<strong>否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程</strong>。</p>
<p>4)如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</p>
<p>正是因为invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，所以<strong>两次调用</strong>中的invokevirtual指令并不是把<strong>常量池中方法的符号引用解析到直接引用上就结束了</strong>，<strong>还会根据方法接者的实际类型来选择方法版本</strong>，这个过程就是Java语言中<strong>方法重写的本质</strong>。我们把这种在<strong>运行期根据实际类型确定方法执行版本的分派过程称为动态分派</strong>。</p>
<p>既然这种多态性的根源在于虚方法调用指令invokevirtual的执行逻辑，那<strong>自然我们得出的结论就只会对方法有效，对字段是无效的</strong>，因为字段不使用这条指令。事实上，<strong>在Java里面只有虚方法存在，字段永远不可能是虚的</strong>，换句话说，字段永远不参与多态，哪个类的方法访问某个名字的字段时，该名字指的就是这个类能看到的那个字段。当<strong>子类声明了与父类同名的字段时，虽然在子类的内存中两个字段都会存在，但是子类的字段会遮蔽父类的同名字段</strong>。</p>
<h4 id="8-3-2-3-单分派与多分派"><a href="#8-3-2-3-单分派与多分派" class="headerlink" title="8.3.2.3 单分派与多分派"></a>8.3.2.3 单分派与多分派</h4><p>方法的接收者与方法的参数统称为方法的宗量，这个定义最早应该来源于著名的《Java与模式》一书。根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211012002707743.png" alt="image-20211012002707743"></p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211012002722173.png" alt="image-20211012002722173"></p>
<p>在main()里调用了两次hardChoice(方法，这两次hardChoice()方法的选择结果在程序输出中已经显示得很清楚了。我们关注的首先是编译阶段中编译器的选择过程，也就是静态分派的过程。这时候选择目标方法的依据有两点:一是静态类型是Father还是Son，二是方法参数是QQ还是360。这次选择结果的最终产物是产生了两条invokevirtual指令，两条指令的参数分别为常量池中指向Fater:hardChoice(360)及Father::hardChoice(QQ)方法的符号引用。<strong>因为是根据两个宗量进行选择，所以Java语言的静态分派属于多分派类型</strong>。</p>
<p>再看看运行阶段中虚拟机的选择，也就是动态分派的过程。在执行“son.hardChoice(new QQ)”这行代码时，更准确地说，是在执行这行代码所对应的invokevirtual指令时，由于编译期已经决定目标方法的签名必须为hardChoice(QQ)，虚拟机此时不会关心传递过来的参数“QQ’ ‘到底是“腾讯QQ”还是“奇瑞QQ”，因为这时候参数的静态类型、实际类型都对方法的选择不会构成任何影响，唯一可以影响虚拟机选择的因素只有该方法的接受者的实际类型是Father还是Son。<strong>因为只有一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型</strong>。</p>
<p>根据上述论证的结果，我们可以总结一句:<strong>如今(直至本书编写的Java 12和预览版的Java 13)的Java语言是一门静态多分派、动态单分派的语言</strong>。强调“如今的Java语言”是因为这个结论未必会恒久不变，C#在3.0及之前的版本与Java-样是动态单分派语言，但在C#4.0中引入了dynam8ic类型后，就可以很方便地实现动态多分派。JDK 10时Java语法中新出现var关键字，但请读者切勿将其与C#中的dynamic类型混淆，事实上Java的var与C#的var才是相对应的特性，它们与dynamic有着本质的区别:var是在编译时根据声明语句中赋值符右侧的表达式类型来静态地推断类型，这本质是一种语法糖;而dy namic在编译时完全不关心类型是什么，等到运行的时候再进行类型判断。Java语 言中与C#的dynamic类型功能相对接近(只是接近，并不是对等的)的应该是在JDK 9时通过JEP 276引入的jdk. dynalink模块61，使用jdk. dy nalink可以实现在表达式中使用动态类型，Javac编译 器会将这些动态类型的操作翻译为invokedynamic指令的调用点。</p>
<h4 id="8-3-2-4-虚拟机动态分派实现"><a href="#8-3-2-4-虚拟机动态分派实现" class="headerlink" title="8.3.2.4 虚拟机动态分派实现"></a>8.3.2.4 虚拟机动态分派实现</h4><p>虚拟机动态分派依靠在方法区中建立一个虚方法表，使用虚方法表索引来代替元数据查找以提高性能。</p>
<p>虚方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的虚方法表也一同初始化完毕。</p>
<h2 id="8-4-动态类型语言支持"><a href="#8-4-动态类型语言支持" class="headerlink" title="8.4 动态类型语言支持"></a>8.4 动态类型语言支持</h2><p><strong>动态语言的关键特征是他的类型检查的主体过程是在运行期而不是编译期进行的。</strong></p>
<h1 id="9-类加载及执行子系统的案例与实战"><a href="#9-类加载及执行子系统的案例与实战" class="headerlink" title="9.类加载及执行子系统的案例与实战"></a>9.类加载及执行子系统的案例与实战</h1><h2 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h2><p>在Class文件格式与执行引擎这部分里，用户的程序能直接参与的内容并不太多，Class文件以何种格式存储，类型何时加载、如何连接，以及虛拟机如何执行字节码指令等都是由虛拟机直接控制的行为，用户程序无法对其进行改变。<strong>能通过程序进行操作的，主要是&#x3D;&#x3D;字节码生成与类加载器&#x3D;&#x3D;这两部分的功能</strong>，但仅仅在如何处理这两点上，就已经出现了许多值得欣赏和借鉴的思路，这些思路后来成为许多常用功能和程序实现的基础。在本章中，我们将看一下前面所学的知识在实际开发之中是如何应用的。</p>
<h2 id="9-2-案例分析"><a href="#9-2-案例分析" class="headerlink" title="9.2 案例分析"></a>9.2 案例分析</h2><h3 id="9-2-4-Backport工具-Java的时光机器"><a href="#9-2-4-Backport工具-Java的时光机器" class="headerlink" title="9.2.4 Backport工具:Java的时光机器"></a>9.2.4 Backport工具:Java的时光机器</h3><h1 id="10-前端编译与优化"><a href="#10-前端编译与优化" class="headerlink" title="10.前端编译与优化"></a>10.前端编译与优化</h1><p>前端主要指与源语言有关但与目标机无关的部分，包括词法分析、语法分析、语义分析与中间表示生成。</p>
<h2 id="10-3-Java语法糖的味道"><a href="#10-3-Java语法糖的味道" class="headerlink" title="10.3 Java语法糖的味道"></a>10.3 Java语法糖的味道</h2><p><strong>语法糖：指的是在计算机语言中添加某种语法，这种语法对语言的编译结果和功能没有实际影响，但是却能更方便程序员使用该语言。</strong></p>
<p><strong>优点</strong></p>
<ol>
<li>或能提高效率</li>
<li>或能提升语法的严谨性</li>
<li>或能减少编码出错的机会</li>
</ol>
<h3 id="10-3-1-泛型"><a href="#10-3-1-泛型" class="headerlink" title="10.3.1 泛型"></a>10.3.1 泛型</h3><p>泛型的本质是<strong>参数化类型</strong>或者<strong>参数化多态</strong>的应用，即可以将操作的数据类型指定为方法签名中的一种特殊参数，这种参数类型能够用在类、接口和方法的创建中，分别构成泛型类、泛型接口和泛型方法。</p>
<p>泛型让程序员能够以针对泛化的数据类型编写相同的算法，这极大地增强了编程语言的类型系统及抽象能力。</p>
<h4 id="10-3-1-1-Java与C-的泛型"><a href="#10-3-1-1-Java与C-的泛型" class="headerlink" title="10.3.1.1 Java与C#的泛型"></a>10.3.1.1 Java与C#的泛型</h4><p>Java选择的泛型实现方式叫作“<strong>类型擦除式泛型</strong>”(Type Erasure Generics ),而C#选择的泛型实现方式是“<strong>具现化式泛型</strong>”( Reified Generics )。</p>
<p>而Java语言中的泛型则不同，它只在程序源码中存在，在编译后的字节码文件中，全部泛型都被替换为原来的裸类型(Raw Type，稍后我们会讲解裸类型具体是什么)了，并且在相应的地方插入了强制转型代码，因此对于运行期的Java语言来说，Array List<int>与Array List&lt;String其实是同一个类型，由此读者可以想象“类型擦除”这个名字的含义和来源，这也是为什么笔者会把Java泛型安排在语法糖里介绍的原因。</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211012193326205.png" alt="image-20211012193326205"></p>
<h4 id="10-3-1-2-泛型的历史背景"><a href="#10-3-1-2-泛型的历史背景" class="headerlink" title="10.3.1.2 泛型的历史背景"></a>10.3.1.2 泛型的历史背景</h4><p>Martin Odersky是Scala缔造者，Java团队找到他，表示对Pizza的泛型很感兴趣，于是就将Pizza语言的泛型单拎出来给Java，本来Pizza的泛型更偏向C#.</p>
<p>可以事实上，因为Java规范中的“二进制向后兼容性”，即一个在JDK 1.2中编译出来的Class文件，必须保证能够在JDK 12乃至以后的版本中也能够正常运行。</p>
<p>所以为了保证这些编译出来的Class文件可以在Java 5.0引入泛型之后继续运行，设计者面前大体上有两条路可以选择:</p>
<p>1)需要泛型化的类型(主要是容器类型)，以前有的就保持不变，然后平行地加一套泛型化版本的新类型。</p>
<p>2)直接把已有的类型泛型化，即让所有需要泛型化的已有类型都原地泛型化，不添加任何平行于已有类型的泛型版。</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211012231327117.png" alt="image-20211012231327117"></p>
<p>但如果相同的选择出现在Java中就很可能不会是相同的结果了，要知道当时.NET才问世两年，而Java已经有快十年的历史了，再加上各自流行程度的不同，两者遗留代码的规模根本不在同一个数量级上。而且更大的问题是Java并不是没有做过第-条路那样的技术决策，在JDK 1.2时，遗留代码规模尚小，Java就引入过新的集合类，并且保留了旧集合类不动。这导致了直到现在标准类库中还有Vector (老)和ArrayList (新)、有Hashtable (老)和HashMap (新)等两套容器代码并存，如果当时再摆弄出像Vector (老)、ArrayList (新)、Vector<T> (老但有泛型)、ArrayList<T> (新且有泛型)这样的容器集合，可能叫骂声会比今天听到的更响更大，<strong>如果选择第一条，则会冒出更多的容器集合，不方便使用</strong>。</p>
<h4 id="10-3-1-3-类型擦除"><a href="#10-3-1-3-类型擦除" class="headerlink" title="10.3.1.3 类型擦除"></a>10.3.1.3 类型擦除</h4><p>我们继续以ArrayList为例来介绍Java泛型的类型擦除具体是如何实现的。由于Java选择了第二条路，直接把已有的类型泛型化。要让所有需要泛型化的已有类型，譬如ArrayList， 原地泛型化后变成了ArrayList<T>，而且保证以前直接用Array List的代码在泛型新版本里必须还能继续用这同一一个容器，这就必须让所有泛型化的实例类型，譬如Array List<Integer>、Array List &lt;String这些全部自动成为ArrayList的子类型才能可以，否则类型转换就是不安全的。由此就引出了“裸类型”(Raw Type)的概念，裸类型应被视为所有该类型泛型化实例的共同父类型(Super Type)，只有这样，像代码清单10-4中的赋值才是被系统允许的从子类到父类的安全转型。</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211012232155486.png" alt="image-20211012232155486"></p>
<p><strong>接下来面对的问题：如何实现裸类型</strong></p>
<ol>
<li>一种是在运行期间由Java虚拟机来自动地、真实地构造出ArrayList<Integer>类型</li>
<li>另外一种是索性简单粗暴地直接在编译时把ArrayList<Integer>还原回ArrayList，只在元素访问、修改时自动插入一些强制类型转换和检查指令。</li>
</ol>
<hr>
<p><strong>类型擦除前和类型擦除后的对比</strong></p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211013191804706.png" alt="image-20211013191804706"></p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211013191846294.png" alt="image-20211013191846294"></p>
<p>把这段Java代码编译成Class文件，然后再用字节码反编译工具进行反编译后，将会发现泛型都不见了，程序又变回了Java泛型出现之前的写法，泛型类型都变回了裸类型。</p>
<p><strong>产生的问题</strong></p>
<p>1.这种情况下，一旦把泛型信息擦除后，到要插入强制转型代码的地方就没办法往下做了，因为不，支持int、long与Object之间的强制转型。当时Java给出的解决方案一如既往的简单粗暴:既然没法转换那就索性别支持原生类型的泛型了吧，你们都用ArrayList<Integer>、 ArrayList<Long>， 反正都做了自动的强制类型转换，遇到原生类型时把装箱、拆箱也自动做了得了。这个决定后面导致了<strong>无数构造包装类和装箱、拆箱的开销</strong>，成为Java泛型慢的重要原因，也成为今天Valhalla项目要重点解决的问题之。</p>
<p>2.我们去写一个泛型版本的从List到数组的转换方法，由于不能从List中取得参数化类型T，所以不得不从一个额外参数中再传入一个数组的组件类型进去，实属无奈。</p>
<p>3.在重载方面遇到的问题：</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211013193125723.png" alt="image-20211013193125723"></p>
<p>这个不能被编译，下面的可以被编译</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211013193239099.png" alt="image-20211013193239099"></p>
<p>这个是不是颠覆了你对重载的认知？</p>
<p><strong>原因：</strong>方法重载要求方法具备不同的特征签名，返回值并不包含在方法的特征签名中，所以返回值不参与重载选择，但是在Class文件格式之中，只要描述符不是完全一致的两个方法就可以共存。<strong>也就是说两个方法如果有相同的名称和特征签名，但返回值不同，那它们也是可以合法地共存于一个Class文件中的</strong>。</p>
<p>擦除法所谓的擦除，仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们在编码时能通过反射手段取得参数化类型的根本依据。</p>
<h3 id="10-3-2-自动装箱、拆箱与遍历循环"><a href="#10-3-2-自动装箱、拆箱与遍历循环" class="headerlink" title="10.3.2 自动装箱、拆箱与遍历循环"></a>10.3.2 自动装箱、拆箱与遍历循环</h3><p>遍历循环就是迭代器的语法糖。</p>
<p>自动拆箱、装箱其实就是Integer.valueOf()加值。</p>
<h1 id="11-后端编译与优化"><a href="#11-后端编译与优化" class="headerlink" title="11.后端编译与优化"></a>11.后端编译与优化</h1><h2 id="11-1-概述"><a href="#11-1-概述" class="headerlink" title="11.1 概述"></a>11.1 概述</h2><p>编译器无论在何时、在何种状态下把Class文件转换成与本地基础设施相关的二进制机器码，他都可以视为整个编译过程的后端。</p>
<p>后端编译器编译性能的好坏、代码优化质量的高低却是衡量一款商用虛拟机优秀与否的关键指标之一。</p>
<h2 id="11-2-即时编译器"><a href="#11-2-即时编译器" class="headerlink" title="11.2 即时编译器"></a>11.2 即时编译器</h2><p>是一个把<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Java/85979">Java</a>的字节码（包括需要被解释的指令的程序）转换成可以直接发送给处理器的指令的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F/71525">程序</a>。</p>
<p>目前主流的两款商用Java虚拟机(HotSpot、 OpenJ9)里，Java程序最初都是通过解释器(Interpreter)进行解释执行的，<strong>当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为“热点代码”(Hot Spot Code)，为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成本地机器码，并以各种手段尽可能地进行代码优化，运行时完成这个任务</strong>的后端编译器被称为<strong>即时编译器</strong>。</p>
<h3 id="11-2-1-解释器与编译器"><a href="#11-2-1-解释器与编译器" class="headerlink" title="11.2.1 解释器与编译器"></a>11.2.1 解释器与编译器</h3><p>尽管并不是所有的Java虛拟机都采用解释器与编译器并存的运行架构，但目前主流的商用Java虚拟机，譬如HotSpot、OpenJ9等， 内部都同时包含解释器与编译器]，解释器与编译器两者各有优势:<strong>当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即运行。当程序启动后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，这样可以减少解释器的中间损耗，获得更高的执行效率</strong>。</p>
<p>当程序运行环境中内存资源限制较大，可以使用解释执行节约内存(如部分嵌入式系统中和大部分的JavaCard应用中就只有解释器的存在)，反之可以使用编译执行来提升效率。</p>
<h3 id="11-2-2-编译对象与触发条件"><a href="#11-2-2-编译对象与触发条件" class="headerlink" title="11.2.2 编译对象与触发条件"></a>11.2.2 编译对象与触发条件</h3><p>被判断为“热点代码”的标准：</p>
<ol>
<li>被多次调用的方法。</li>
<li>被多次执行的循环体。</li>
</ol>
<p><strong>被多次调用的方法</strong>：前者很好理解，一个方法被调用得多了，方法体内代码执行的次数自然就多，它成为“热点代码”是理所当然的。</p>
<p><strong>被多次执行的循环体</strong>：为了解决当一个方法只被调用过一次或少量的几次，但是方法体内部存在循环次数较多的循环体，这样循环体的代码也被重复执行多次，因此这些代码也应该认为是“热点代码”。</p>
<hr>
<p><strong>即时编译被触发的条件</strong></p>
<p><strong>热点探测：</strong>判断某段代码是不是热点代码，是不是需要触发即时编译。</p>
<p>目前主流的热点探测判断方式：</p>
<p>.<strong>基于采样的热点探测</strong>(SampleBasedHotSpotCodeDetection)。采用这种方法的虛拟机会周期性地检查各个线程的调用栈顶，如果发现某个(或某些)方法经常出现在栈项，那这个方法就是“热点方法”。基于采样的热点探测的<strong>好处</strong>是实现简单高效，还可以很容易地获取方法调用关系(将调用堆栈展开即可)，<strong>缺点</strong>是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</p>
<p>.<strong>基于计数器的热点探测</strong>(Counter Based Hot Spot Code Detection) 。采用这种方法的虚拟机会为每个方法(甚至是代码块)建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为它是“热点方法”。这种统计方法实现起来要麻烦一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系。但是它的统计结果相对来说更加精确严谨。</p>
<p>HotSpot使用的是第二种基于计数器的热点探测，方法，为了实现热点计数，HotSpot为每个 方法准备了<strong>两类计数器:方法调用计数器( Invocation Counter)和回边计数器</strong>( Back Edge Counter），“回边”的意思就是指在循环边界往回跳转)。<strong>当虚拟机运行参数确定的前提下，这两个计数器都有一个明确的阈值，计数器阈值一旦溢出，就会触发即时编译</strong>。</p>
<p><strong>调用计数器</strong>的使用规则：当一个方法被调用时，虚拟机会先检查该方法是否存在被即时编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将该方法的调用计数器值加一，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。一旦已超过阈值的话，将会向即时编译器提交一个该方法的代码编译请求。</p>
<p>在默认设置下，<strong>方法调用计数器统计的并不是方法被调用的绝对次数</strong>，而是一个相对的执行频率，即<strong>一段时间之内方法被调用的次数</strong>。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那该方法的调用计数器就会被减少一半，这个过程被称为方法**调用计数器热度的衰减(Counter Decay)**，而这段时间就称为此方法统计的半衰周期(Counter Half Life Time)。</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211014151347446.png" alt="image-20211014151347446"></p>
<p><strong>回边计数器：</strong>它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令就称为“回边”，<strong>目的：</strong>很显然，建立回边计数器统计的目的是为了<strong>触发栈上的替换编译</strong>。</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211014152035801.png" alt="image-20211014152035801"></p>
<hr>
<p><strong>两者的不同之处</strong></p>
<p><strong>与方法计数器不同，回边计数器没有计数热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数</strong>。当计数器溢出的时候，它还会把方法计数器的值也调整到溢出状态，这样下次再进入该方法的时候就会执行标准编译过程。</p>
<h3 id="11-2-3-编译过程"><a href="#11-2-3-编译过程" class="headerlink" title="11.2.3 编译过程"></a>11.2.3 编译过程</h3><p>在默认条件下，无论是方法调用产生的标准编译请求，还是栈上替换编译请求，虚拟机在编译器还未完成编译之前，都任然将按照解释方式继续执行代码，而编译动作则在后台的编译线程中进行。</p>
<hr>
<p><strong>客户端的编译过程：</strong></p>
<p>他是一个相对简单快速的三段式编译器，主要关注点在局部优化，而放弃许多耗时较长的全局优化手段。</p>
<ol>
<li>一个平台独立的前端将字节码构造成一种高级中间代码表示。</li>
<li>一个平台相关的后端从HIR中产生低级中间代码表示。</li>
<li>最后阶段是在平台相关的后端使用线性扫描算法。</li>
</ol>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211014153707970.png" alt="image-20211014153707970"></p>
<hr>
<p><strong>服务端编译器</strong></p>
<p>而服务端编译器则是专门面向服务端的典型应用场景，并为服务端的性能配置针对性调整过的编译器，也是一个能容忍很高优化复杂度的高级编译器。</p>
<p>它会执行大部分经典的优化动作，如:无用代码消除( Dead Code Elimination)、循环展开(Loop Unrolling)、循环表达式外提(Loop Expression Hoisting)、消除公共子表达式(Common Subexpression Elimination)、常量传播(Constant Propagation)、基本块重排序( Basic Block Reordering)等，还会实施一些与Java语言特性密切相关的优化技术，如范围检查消除( Range Check<br>Elimination)、空值检查消除(NullCheckElimination,不过并非所有的空值检查消除都是依赖编译器优化的，有一一些是代码运行过程中自动优化了)等。另外，还可能根据解释器或客户端编译器提供的性能监控信息，进行一些不稳定的预测性激进优化，如守护内联(GuardedInlining)、分支频率预测( Branch Frequency Prediction)。</p>
<h2 id="11-3-提前编译器"><a href="#11-3-提前编译器" class="headerlink" title="11.3 提前编译器"></a>11.3 提前编译器</h2><p>提前编译器（Ahead Of Time Compiler，AOT编译器）：直接把程序编译成与目标机器指令集相关的二进制代码的过程。目前有两种主要的实现方式：</p>
<ul>
<li>与传统C、C++编译器类似，在程序运行之前把程序代码编译成机器码的静态翻译工作</li>
<li>把原本即时编译器在运行时要做的编译工作提前做好并保存下来，下次运行到这些代码（譬如公共库代码在被同一台机器其他Java进程使用）时直接把它加载进来使用。</li>
</ul>
<p>第一种实现方式在Java中的存在价值直指即时编译的最大弱点：即时编译要占用程序运行时间和运算资源。例如最耗时的优化措施之一：过程见分析，必须在全程序范围内做大量耗时的计算工作，如果是在程序运行之前进行的静态编译，这些耗时操作就可以大胆的进行。</p>
<p>对于第二种方式，本质上是给即时编译器做缓存加速，去改善Java程序的启动时间，以及需要一段时间预热之后才能达到最高性能的问题。这种提前编译被称为动态提前编译或者直接叫即时编译缓存。HotSpot运行时可以直接加载这些编译结果，实现快速程序启动速度，减少程序达到全速运行状态所需要的时间。</p>
<p>但是即时编译相比于提前编译也有很多优点：</p>
<p><strong>性能分析制导优化</strong>。解释器和客户端编译器在运行期间会不断收集性能监控信息，这些信息一般无法在静态分析是获得，或者不一定存在唯一的解，但在动态运行时很容易得到</p>
<p><strong>激进预测性优化</strong>。静态优化无论何时都必须保证优化后的所有程序外部可见影响（不仅仅是执行结果）与优化前必须是一致的。即时编译的策略就可以不必那么保守，如果性能监控信息能够支持它做出一些正确的可能很大但是无法保证绝对正确的预测判断，就可以进行大胆的优化，大不了退回到低级i按一起甚至解释器上运行。而这样的优化往往能够大幅度降低目标程序的复杂度，输出运行速度非常高的代码。</p>
<p><strong>链接时优化</strong>：由于Java天生是动态连接的，所以提前编译无法做到链接后的优化。</p>
<h2 id="11-4-编译器优化技术"><a href="#11-4-编译器优化技术" class="headerlink" title="11.4 编译器优化技术"></a>11.4 编译器优化技术</h2><p><strong>编译器的目标虽然是做程序代码翻译为本地机器 码的工作，但其实难点并不在于能不能成功翻译出机器码，输出代码优化质量的高低才是决定编译器优秀与否的关键。</strong></p>
<h3 id="11-4-1-优化技术概览"><a href="#11-4-1-优化技术概览" class="headerlink" title="11.4.1 优化技术概览"></a>11.4.1 优化技术概览</h3><p>即时编译器对这些代码优化变换是建立在代码的中间表示或者机器码之上的，绝不是直接在Java源码上去做的。</p>
<p><strong>方法内联-&gt;冗余访问消除-&gt;复写传播-&gt;无用代码消除</strong></p>
<ol>
<li>最重要的优化技术之一：方法内联</li>
<li>最前沿的优化技术之一：逃逸分析</li>
<li>语言无关的经典优化技术之一：公共因子表达式消除</li>
<li>语言相关的经典优化技术之一：数组边界检查消除</li>
</ol>
<h3 id="11-4-2-方法内联"><a href="#11-4-2-方法内联" class="headerlink" title="11.4.2 方法内联"></a>11.4.2 方法内联</h3><p><strong>方法内联可以说是最重要的技术，可以去掉“之一”</strong></p>
<p><strong>作用</strong>：除了消除方法调用的成本之外，它更重要的意义是为其他优化手段建立良好的基础。</p>
<hr>
<p><strong>过程</strong></p>
<p>表面上方法内联的优化行为就是把目标方法的代码原封不动的“复制”到发起调用的方法之中，避免发生真实地方法调用而已。</p>
<hr>
<p><strong>遇到问题</strong></p>
<p>对于一个虚方法，编译器静态地去做内联的时候很难确定应该使用哪个版本方法版本，在Java选择了在虚拟机中解决这个问题。</p>
<p><strong>解决方法</strong></p>
<p>**类型继承关系分析(CHA)**：这是整个应用程序范围内的类型分析技术，用于确定在目前已加载类中，某个接口是否有多于一种的实现、某个类是否存在子类、某个子类是否覆盖了父类的某个虚方法等信息。</p>
<p><strong>解决过程</strong></p>
<p>如果是非虚方法，那么直接进行内联就可以了，这种内联是有百分百安全保证的。</p>
<p>如果遇到虚方法，则会向CHA查询此方法在当前程序状态下是否真的有多个目标版本可供选择，如果查询到只有一个版本，那就可以假设“应用程序的全貌就是现在运行的这个样子”来进行内联，这种内联被称为<strong>守护内联</strong>，内置“逃生门”，如果当前条件不成立，就会退回到解释状态进行执行。</p>
<p><strong>内联缓存：</strong>如果该方法确实有多个版本的目标方法可供选择，那即时编译器还将进行最后一次努力，使用内联缓存的方式来缩减方法调用的开销。</p>
<p><strong>工作原理：</strong>在未发生方法调用之前，内联缓存状态为空，当第一次调用发生后，缓存记录下方法接收者的版本信息，并且每次进行方法调用时都比较接收者的版本。如果以后进来的每次调用的方法接收者版本都是一样的，那么这时他就是一种单态内联缓存。通过该缓存来调用，比用不内联的<strong>非虚方法调用</strong>，仅多了一次类型判断的开销而已。 </p>
<p>通过该缓存来调用，比用不内联的非虛方法调用，仅多了一次类型判断的开销而已。但如果真的出现方法接收者不一致的情况，就说明程序用到了虛方法的多态特性，这时候会退化成<strong>超多态内联缓存</strong>(Megamorphic Inline Cache)，其开销相当于真正查找虚方法表来进行方法分派。</p>
<h3 id="11-4-3-逃逸分析"><a href="#11-4-3-逃逸分析" class="headerlink" title="11.4.3 逃逸分析"></a>11.4.3 逃逸分析</h3><p><strong>逃逸分析的基本原理是</strong>:分析对象动态作用域，当一个对象在方法里面被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，这种称为方法逃逸;甚至还有可能被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量，这种称<strong>为线程逃逸;从不逃逸、方法逃逸到线程逃逸</strong>，称为对象<strong>由低到高的不同逃逸程度</strong>。</p>
<hr>
<p><strong>由逃逸程度从高到底，虚拟机会采取不同的优化：</strong></p>
<p><strong>栈上分配：</strong>如果确定一个象不会逃逸出线程之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧出栈而销毁。在一般应用中，完全不会逃逸的局部对象和不会逃逸出线程的对象所占的比例是很大的，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，垃圾收集子系统的压力将会下降很多。栈上分配可以支持方法逃逸，但不能支持线程逃逸，(<strong>将对象分配到栈上，这个思想很不错</strong>)。</p>
<p><strong>标量替换：</strong></p>
<ol>
<li>标量：若一个数据已经无法再分解成更小的数据来表示了，Java虛拟机中的原始数据类型(int、long等数值类型及reference类型等)都不能再进一步分解了，那么这些数据就可以被称为标量。</li>
<li>聚合量：如果一个数据可以继续分解，那么它就被称为聚合量。</li>
</ol>
<p><strong>工作原理：</strong></p>
<p>假如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么程序真正执行的时候将可能不去创建这个对象，而改为直接创建它的若干个被这个方法使用的成员变量来代替。将对象拆分后，除了可以让对象的成员变量在栈上(栈上存储的数据，很大机会被虛拟机分配至物理机器的高速寄存器中存储)分配和读写之外，还可以为后续进一步的优化手段创建条件。</p>
<p><strong>标量替换可以看作栈上分配的一种特殊案例，实现更简单，但对逃逸程度的要求更高，他不允许对象逃逸出方法范围内。</strong></p>
<p><strong>同步消除：</strong></p>
<p>线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以安全地消除掉。</p>
<hr>
<p><strong>不成熟的原因</strong>：不成熟的原因主要是逃逸分析的计算成本非常高，甚至不能保证逃逸分析带来的性能收益会高于它的消耗，尤其是大型程序中反而发现实施逃逸分析可能出现效果不稳定的情况。如果逃逸分析完毕后发现几乎找不到几个不逃逸的对象，那这些运行器好用的时间就白白浪费了。</p>
<h3 id="11-4-4-公共子表达式消除"><a href="#11-4-4-公共子表达式消除" class="headerlink" title="11.4.4 公共子表达式消除"></a>11.4.4 公共子表达式消除</h3><p>公共子表达式：如果一个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就称为公共子表达式。</p>
<h3 id="11-4-5-数组边界检查消除"><a href="#11-4-5-数组边界检查消除" class="headerlink" title="11.4.5 数组边界检查消除"></a>11.4.5 数组边界检查消除</h3><p>超出边界抛出异常</p>
<h1 id="12-Java内存模型与线程"><a href="#12-Java内存模型与线程" class="headerlink" title="12.Java内存模型与线程"></a>12.Java内存模型与线程</h1><h2 id="12-1-概述"><a href="#12-1-概述" class="headerlink" title="12.1 概述"></a>12.1 概述</h2><h2 id="12-2-硬件的效率与一致性"><a href="#12-2-硬件的效率与一致性" class="headerlink" title="12.2 硬件的效率与一致性"></a>12.2 硬件的效率与一致性</h2><p>数据不安全的原因：缓存一致性的问题</p>
<p><strong>共享内存多核系统</strong>：在多路处理器系统中，每个处理器都有自己的高速缓存，而他们又共享同一主内存。</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211018093836688.png" alt="image-20211018093836688"></p>
<p><strong>线程先后执行结果不一致问题：</strong>除了增加高速缓存之外，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行<strong>乱序执行</strong>(Out-Of-Order Execution)优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java虛拟机的即时编译器中也有指令重排序( Instruction Reorder)优化。</p>
<h2 id="12-3-Java内存模型"><a href="#12-3-Java内存模型" class="headerlink" title="12.3 Java内存模型"></a>12.3 Java内存模型</h2><p>JDK5之后Java内存模型逐渐完善起来。</p>
<h3 id="12-3-1-主内存与工作内存"><a href="#12-3-1-主内存与工作内存" class="headerlink" title="12.3.1 主内存与工作内存"></a>12.3.1 主内存与工作内存</h3><p><strong>Java内存模型目的</strong>：定义程序中各种变量的访问规则，即关注在虚拟机中把变量(Java中的实例字段、静态字段、构成数组的对象元素)值存储到内存和从内存中取出变量(Java中的实例字段、静态字段、构成数组的对象元素)值这样的底层细节。</p>
<p><strong>规定：</strong></p>
<ol>
<li>Java内存模型规定所有变量都存储在主内存中。</li>
<li>线程工作内存中保存了被该线程使用的变量的主内存副本(复制的是引用)。</li>
<li>线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的数据。</li>
<li>不同的线程之间也无法直接访问对方工作内存中的变量。</li>
</ol>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211018093757517.png" alt="image-20211018093757517"></p>
<p>Java内存与Java内存区域对应的关系：主内存对应于Java堆中的对象实例数据部分，工作内存对应于虚拟机栈中的部分区域。</p>
<h3 id="12-3-2-内存间交互操作"><a href="#12-3-2-内存间交互操作" class="headerlink" title="12.3.2 内存间交互操作"></a>12.3.2 内存间交互操作</h3><p><strong>一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存这一类的实现细节。</strong></p>
<p>注：Java虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的。</p>
<p>关于上面过程Java内存模型定义了以下8种操作：</p>
<ul>
<li>**lock(锁定)**：作用于主内存的变量，他把一个变量标识为一条线程独占的状态。</li>
<li>**unlock(解锁)**：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li><strong>read (读取)</strong> :作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li>
<li><strong>load (载入)</strong> :作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>**use(使用)**：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虛拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li>
<li>**assign (赋值)**：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量,每当虛拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li><strong>store (存储)</strong> :作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li>
<li>**write(写入)**：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li>
</ul>
<p>Java内存要求read和load或store和write必须按顺序执行。</p>
<p><strong>同时Java内存规定在执行上述8种基本操作时必须满足以下规则：</strong></p>
<ul>
<li>不允许read和load、store和write操作之 一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现。</li>
<li>不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li>
<li>不允许一个线程无原因地(没有发生过任何assign操作)把数据从线程的工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化(load或assign)的变量，换句话说就是对一个变量实施use、store操作之前，必须先执行assign和load操作。</li>
<li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数unlock操作，变量才会被解锁。</li>
<li>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操 作以初始化变量的值。</li>
<li>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。</li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中(执行store、write操作)</li>
</ul>
<p><strong>基于以上规定，再加上volatile的一些特殊规定，就能准确地描述Java程序中哪些内存访问操作是安全的</strong></p>
<h3 id="12-3-3-对于volatile型变量的特殊规则"><a href="#12-3-3-对于volatile型变量的特殊规则" class="headerlink" title="12.3.3 对于volatile型变量的特殊规则"></a>12.3.3 对于volatile型变量的特殊规则</h3><p>关键字volatile可以说是Java虚拟机提供的最轻量级别的同步机制。</p>
<h3 id="12-3-4-针对long和double型变量的特殊规则"><a href="#12-3-4-针对long和double型变量的特殊规则" class="headerlink" title="12.3.4 针对long和double型变量的特殊规则"></a>12.3.4 针对long和double型变量的特殊规则</h3><p><strong>Long和Double的非原子性协定</strong>：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现自行选择是否要保证64位数据类型的load、store、 read和write这四个操作的原子性。</p>
<p>32位虚拟机确实会产生long、double的非原子性访问的风险。</p>
<p>在实际开发中，除非该数据有明确可知的线程竞争，否则我们在编写代码时一般不需要因为这个原因刻意把用到long和double变量专门声明为volatile。</p>
<h3 id="12-3-5-原子性、可进行与有序性"><a href="#12-3-5-原子性、可进行与有序性" class="headerlink" title="12.3.5 原子性、可进行与有序性"></a>12.3.5 原子性、可进行与有序性</h3><h4 id="12-3-5-1-原子性"><a href="#12-3-5-1-原子性" class="headerlink" title="12.3.5.1 原子性"></a>12.3.5.1 原子性</h4><p><strong>Java内存模型围绕着在并发过程中如何处理原子性、可见性和有序性这三个特征来建立的。</strong></p>
<hr>
<p>Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个。我们大致可以认为，基本数据类型的访问、读写都是具备原子性的。</p>
<p><strong>synchronized关键字与虚拟机的关系</strong></p>
<p>如果应用场景需要一个更大范围的原子性保证(经常会遇到)，Java内存模型还提供了lock和unlock操作来满足这种需求，尽管虛拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作。这两个字节码指令反映到Java代码中就是同步块一synchronized关键字，因此在synchronized块之间的操作也具备原子性。</p>
<h4 id="12-3-5-2-可见性"><a href="#12-3-5-2-可见性" class="headerlink" title="12.3.5.2 可见性"></a>12.3.5.2 可见性</h4><p>可见性就是指当前一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。</p>
<hr>
<p><strong>实现</strong>：Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性。</p>
<p><strong>区别：</strong>普通变量与volatile(哇了特)变量的区别是：volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此我们可以说<strong>volatile保证了多线程操作时变量的可见性</strong>，而普通变量则不能保证这一点。</p>
<p>除了volatile之外，Java还有两个关键字能实现可见性，它们是<strong>synchronized和final</strong>。<strong>同步块的可见性</strong>：是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中(执行store、write操作)”这条规则获得的。<strong>而final关键字的可见性是指</strong>：被final修饰的字段在构造器中—旦被初始化完成，并且构造器没有把“this”的引用传递出去(this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象)，那么在其他线程中就能看见final字段的值。</p>
<h4 id="12-3-5-3-有序性"><a href="#12-3-5-3-有序性" class="headerlink" title="12.3.5.3 有序性"></a>12.3.5.3 有序性</h4><p><strong>如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。</strong></p>
<p>所有的操作都是无序的。前半句是指“线程内似表现为串行的语义”(Within-Thread As-If-Serial Semantics)，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。</p>
<hr>
<p>Java语言提供了volatile和synchronized两个关键字保证线程之间操作的有序性。</p>
<p>volatile关键字本身就包含了<strong>禁止指令重排序</strong>的语义。</p>
<p>synchronized则是由“一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。</p>
<h3 id="12-3-6-先行发生原则"><a href="#12-3-6-先行发生原则" class="headerlink" title="12.3.6 先行发生原则"></a>12.3.6 先行发生原则</h3><p>概念：现在就来看看“先行发生”原则指的是什么。先行发生是Java内存模型中定义的两项操作之间的偏序关系，比如说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。</p>
<p>作用：<strong>它是判断数据是否存在竞争，线程是否安全地非常有用地手段</strong>。</p>
<hr>
<p>如果两个操作之间的关系不在此列，并且无法从下列规则推导出来，则它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。</p>
<ul>
<li>程序次序规则( Program Order Rule) :在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</li>
<li>管程锁定规则(Monitor Lock Rule) :一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是“同一个锁”，而“后面”是指时间上的先后。</li>
<li>volatile变量规则( Volatile Variable Rule) :对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后。</li>
<li>线程启动规则(Thread Start Rule)：Thread对象的start()方法先行发生于此线程的每一个动作。</li>
<li>线程终止规则(Thread Termination Rule) ：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread:join()方法是否结束、Thread:isAlive()的返 回值等手段检测线程是否已经终止执行。</li>
<li>线程中断规则(Thread Interruption Rule) :对线程interrupt(方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Threa:interrupted0方法检测到是否有中断发生。</li>
<li>对象终结规则(Finalizer Rule) : 一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize(方法的开始。</li>
<li>传递性 (Transitivity) :如果操作A先行发生于操作B，操作B先行发生于操作C,那就可以得出操作A先行发生于操作C的结论。</li>
</ul>
<p>&#x3D;&#x3D;p454页深入理解先行发生原则&#x3D;&#x3D;</p>
<h2 id="12-4-Java与线程"><a href="#12-4-Java与线程" class="headerlink" title="12.4 Java与线程"></a>12.4 Java与线程</h2><h3 id="12-4-1-线程的实现"><a href="#12-4-1-线程的实现" class="headerlink" title="12.4.1 线程的实现"></a>12.4.1 线程的实现</h3><p>线程是比进程更轻量级地调度执行单位，线程地引入，可以把一个进程地资源分配和执行调度分开，各个线程即可以共享进程资源，又可以独立调用。</p>
<p><strong>目前线程是Java里面进行处理资源调度地最基本单位，但是日后可能会出来纤程。</strong></p>
<p>Thread这个特别的类所有方法都用Native声明。</p>
<p>实现线程的三种方式：</p>
<ol>
<li>使用内核线程实现(1:1实现)</li>
<li>使用用户线程实现(1:N实现）</li>
<li>使用用户线程加轻量级进程混合实现(N:M实现)</li>
</ol>
<h4 id="12-4-1-1-内核线程实现"><a href="#12-4-1-1-内核线程实现" class="headerlink" title="12.4.1.1 内核线程实现"></a>12.4.1.1 内核线程实现</h4><p>内核线程(Kernel-Level Thread, KLT) 就是直接由操作系统内核(Kernel， 下称内核) 支持的线程。</p>
<hr>
<p><strong>优点</strong>：由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使其中某一个轻量级进程在系统调用中被阻塞了，也不会影响整个进程继续工作。</p>
<p><strong>缺点</strong>：要消耗内存资源，所以一个系统支持地轻量级进程地数量是有限的。</p>
<hr>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211018143040674.png" alt="image-20211018143040674"></p>
<h4 id="12-4-1-2-用户线程实现"><a href="#12-4-1-2-用户线程实现" class="headerlink" title="12.4.1.2 用户线程实现"></a>12.4.1.2 用户线程实现</h4><p><strong>概念</strong>：而狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存在及如何实现的。</p>
<hr>
<p><strong>优点</strong>：快速且低消耗，能够支持更大地线程数量。</p>
<p><strong>缺点</strong>：线程的创建、销毁、切换和调度都需要用户自己手动完成。</p>
<hr>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211018143139724.png" alt="image-20211018143139724"></p>
<p>GoLang、Erlang都使用这种线程。</p>
<p>Java、Ruby以前使用，但现在弃用了。</p>
<h4 id="12-4-1-3-混合实现"><a href="#12-4-1-3-混合实现" class="headerlink" title="12.4.1.3 混合实现"></a>12.4.1.3 混合实现</h4><p>将内核进程与用户线程一起使用地实现方式。</p>
<hr>
<p><strong>优点：</strong>降低阻塞、得到平衡</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211018143515429.png" alt="image-20211018143515429"></p>
<h4 id="12-4-1-4-Java线程地实现"><a href="#12-4-1-4-Java线程地实现" class="headerlink" title="12.4.1.4 Java线程地实现"></a>12.4.1.4 Java线程地实现</h4><p>HotSpot中使用的是1:1的线程模型。</p>
<h3 id="12-4-2-Java线程调度"><a href="#12-4-2-Java线程调度" class="headerlink" title="12.4.2 Java线程调度"></a>12.4.2 Java线程调度</h3><p><strong>Java的线程是被映射到系统的原生线程上实现的</strong></p>
<p>线程调度是指系统为线程分配处理器使用权的过程，调度主要方式有两种，分别是<strong>协同式线程调度</strong>和<strong>抢占式线程调度</strong>。</p>
<p><strong>协同式线程调度</strong>：如果使用协同式调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上去。</p>
<p><strong>优点</strong>：实现简单，而且由于线程要把自己的事情淦完后才会进行线程切换，切换操作对线程自己是可知的，所以一般没有什么线程同步的问题。</p>
<p><strong>缺点</strong>：线程执行时间不可控制，甚至如果一个线程的代码编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在那里。</p>
<p>**抢占式线程调度(java使用的)**：每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定。</p>
<p><strong>优点</strong>：线程的执行时间是系统可控的，也不会有一个线程导致整个进程甚至整个系统阻塞的问题。</p>
<hr>
<p>除此之外：Java语言一共设置了10个优先级别的线程优先级，在两个线程同时处于ready状态时，优先级越高的线程越容易被系统执行。</p>
<h3 id="12-4-3-状态转换"><a href="#12-4-3-状态转换" class="headerlink" title="12.4.3 状态转换"></a>12.4.3 状态转换</h3><p>Java语言定义了6种线程状态，在任意一个时间点种，一个线程只能有且只有其中的一种状态。</p>
<ul>
<li><strong>新建(New)</strong>:创建后尚未启动的线程处于这种状态。</li>
<li><strong>运行(Runnable)</strong> :包括操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着操作系统为它分配执行时间。</li>
<li><strong>无限期等待(Waiting)</strong>:处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线程显式唤醒。以下方法会让线程陷入无限期的等待状态<ul>
<li>没有设置Timeout参数的Object:wait()方法;</li>
<li>没有设置Timeout参数的Thread:join(方法;</li>
<li>LockSupport:park()方法。</li>
</ul>
</li>
<li><strong>限期等待(TimedWaiting)</strong>:处于这种状态的线程也不会被分配处理器执行时间，不过无须等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态:<ul>
<li>Thread::sleep()方法;</li>
<li>设置了Timeout参数的Object:wait()方法;</li>
<li>设置了Timeout参数的Thread:join()方法;</li>
<li>LockSupport:parkNanos()方法;</li>
<li>LockSupport:parkUntil()方法。</li>
</ul>
</li>
<li><strong>阻塞(Blocked)</strong> :线程被阻塞了，“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生;而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</li>
<li><strong>结束(Terminated)</strong> :已终止线程的线程状态，线程已经结束执行。</li>
</ul>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211018155236289.png" alt="image-20211018155236289"></p>
<h2 id="12-5-Java与协程"><a href="#12-5-Java与协程" class="headerlink" title="12.5 Java与协程"></a>12.5 Java与协程</h2><p>在Java时代的早期，<strong>Java语言抽象出来隐藏了各种操作系统线程差异性的统一线程接口， 这曾经是它区别于其他编程语言的一大优势</strong>。在此基础上，涌现过无数多线程的应用与框架，譬如在网页访问时，HTTP请求可以直接与Servlet API中的一条处理线程绑定在一起，以“一对一服务”的方式处理由浏览器发来的信息。</p>
<h3 id="12-5-1-内核线程的局限"><a href="#12-5-1-内核线程的局限" class="headerlink" title="12.5.1 内核线程的局限"></a>12.5.1 内核线程的局限</h3><p>在B&#x2F;S架构中，如今几百万的流量打进来，传统的Java Web服务器的线程池的容量通常在几十个到两百之间，当程序员把数以百万计的请求往线程池里面灌时，系统即使能处理得过来，但其中的切换损耗也是相当可观的。现实的需求在迫使Java去研究新的解决方案，同大家又开始怀念以前绿色线程的种种好处，绿色线程已随着Classic虛拟机的消失而被尘封到历史之中，它还会有重现天日的一天吗?</p>
<h3 id="12-5-2-协程的复苏"><a href="#12-5-2-协程的复苏" class="headerlink" title="12.5.2 协程的复苏"></a>12.5.2 协程的复苏</h3><p>内核线程的调度成本主要来自于用户态与核心态之间的状态转换，而这两种状态转换的开销主要来自于响应中断、保护和恢复执行现场的成本。</p>
<p>由于最初多数的用户线程是被设计成协同式调度(Cooperative Scheduling)的，所以它有了一个别名-“<strong>协程</strong>”(Coroutine) 。</p>
<ul>
<li>有栈协程：由于这时候的协程会完整地做调用栈的保护、恢复工作，所以今天也被称为“有栈协程”(Stackfull Coroutine)。</li>
<li>无栈协程：各种语言中的await、async、yield这类关键字。无栈协程本质上是一种有限状态机，状态保存在闭包里，自然比有栈协程恢复调用栈要轻量得多。</li>
</ul>
<p><strong>优点</strong>：协程的优点就是轻量，一个协程通常只有几百个字节到几KB之间，一个线程默认1MB。</p>
<h3 id="12-5-3-Java的解决方案"><a href="#12-5-3-Java的解决方案" class="headerlink" title="12.5.3 Java的解决方案"></a>12.5.3 Java的解决方案</h3><p><strong>有栈协程的一种特例叫做纤程。</strong></p>
<h1 id="13-线程安全与锁优化"><a href="#13-线程安全与锁优化" class="headerlink" title="13 线程安全与锁优化"></a>13 线程安全与锁优化</h1><p><strong>首先保证并发的正确性，然后在此基础上来实现高效</strong></p>
<h2 id="13-2-线程安全"><a href="#13-2-线程安全" class="headerlink" title="13.2 线程安全"></a>13.2 线程安全</h2><p>当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是<strong>线程安全</strong>的。</p>
<h3 id="13-2-1-Java语言中的线程安全"><a href="#13-2-1-Java语言中的线程安全" class="headerlink" title="13.2.1 Java语言中的线程安全"></a>13.2.1 Java语言中的线程安全</h3><p>Java中，线程安全具体是如何体现的？有哪些操作是线程安全的？</p>
<p>按照线程安全的”安全程度”由强至弱来排序，我们可以将Java语言中各种操作的数据分为以下五类：不可变、绝对线程安全、相对线程安全、线程兼容、线程对立。</p>
<h4 id="13-2-1-1-不可变"><a href="#13-2-1-1-不可变" class="headerlink" title="13.2.1.1 不可变"></a>13.2.1.1 不可变</h4><p>不可变的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要在进行任何线程安全保障措施。</p>
<p><strong>不可变带来的安全性是最直接的、最纯粹的。</strong></p>
<hr>
<p><strong>要求：</strong>final关键字修饰的，即没有发生this引用逃逸。</p>
<hr>
<p><strong>实现：</strong></p>
<ul>
<li>如果多线程共享的数据是一个基本数据类型，那么定义时加上个final关键字就好了</li>
<li>如果共享的数据是一个对象，要求对象自行保证其行为不会对其状态产生任何影响才行。一种解决方法就是把对象里面带有状态的变量都声明为final。</li>
</ul>
<h4 id="13-2-1-2-绝对线程安全"><a href="#13-2-1-2-绝对线程安全" class="headerlink" title="13.2.1.2 绝对线程安全"></a>13.2.1.2 绝对线程安全</h4><p>绝对的线程安全能够完全满足BrianGoetz给出的线程安全的定义，这个定义其实是很严格的，一个类要达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”可能需要付出非常高昂的。</p>
<p>一些线程安全的类，如果不在方法调用端做额外的同步措施，使用这段代码仍然是不安全的。</p>
<h4 id="13-2-1-3-相对线程安全"><a href="#13-2-1-3-相对线程安全" class="headerlink" title="13.2.1.3 相对线程安全"></a>13.2.1.3 相对线程安全</h4><p>相对线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单次的操作是线程安全的，我们在调用的时候不需要进行额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</p>
<h4 id="13-3-1-4-线程兼容"><a href="#13-3-1-4-线程兼容" class="headerlink" title="13.3.1.4 线程兼容"></a>13.3.1.4 线程兼容</h4><p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。我们平常说一个类不是线程安全的，通常就是指这种情况。</p>
<h4 id="13-3-1-5-线程对立"><a href="#13-3-1-5-线程对立" class="headerlink" title="13.3.1.5 线程对立"></a>13.3.1.5 线程对立</h4><p>线程对立是指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码。</p>
<p>一个线程对立的例子是Thread类的suspend()和resume()方法。如果有两个线程同时持有一个线程对象，一个尝试去中断线程，一个尝试去恢复线程，在并发进行的情况下，无论调用时是否进行了同步，目标线程都存在死锁风险一假 如suspend(中断的线程就是即将要执行resume()的那个线程，那就肯定要产生死锁了。也正是这个原因，suspend()和resume()方法都已经被声明废弃了。常见的线程对立的操作还有System.setIn()、System.setOut()和System. runFinalizersOnExit()等。</p>
<h3 id="13-2-2-线程安全的实现方法"><a href="#13-2-2-线程安全的实现方法" class="headerlink" title="13.2.2 线程安全的实现方法"></a>13.2.2 线程安全的实现方法</h3><h4 id="13-2-2-1-互斥同步"><a href="#13-2-2-1-互斥同步" class="headerlink" title="13.2.2.1 互斥同步"></a>13.2.2.1 互斥同步</h4><p>互斥同步(MutualExclusion&amp;Synchronization)是一种最常见也是最主要的并发正确性保障手段。<strong>同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条(或者是一些，当使用信号量的时候)线程使用</strong>。<strong>而互斥是实现同步的一种手段</strong>，临界区(Critical Section)、互斥量(Mutex)和信号量( Semaphore)都是常见的互斥实现方式。因此在“互斥同步”这四个字里面，<strong>互斥是因，同步是果;互斥是方法，同步是目的。</strong></p>
<hr>
<p>其他名称：阻塞同步、悲观锁。面临的问题主要是进行线程阻塞和唤醒所带来的性能开销。</p>
<hr>
<p>在Java里面，最基本的互斥同步手段就是synchronized关键字，这是一种块结构(Block Structured)的同步语法。</p>
<p><strong>Synchronized内部结构</strong></p>
<p>synchronized关键字经过Javac编译之后，会在同步块的<strong>前后分别形成monitorenter和monitorexit这两个字节码指令</strong>。这两个字节码指令都需要一个<strong>reference类型的参数来指明要锁定和解锁的对象</strong>。如果Java源码中的synchronized明确指定了对象参数，那就以这个对象的引用作为reference;如果没有明确指定，**那将根据synchronized修饰的方法类型(如实例方法或类方法)**，来决定是取代码所在的对象实例还是取类型对应的Class对象来作为线程要持有的锁。</p>
<p><strong>Synchronized原理和实现过程</strong></p>
<p>根据《Java虚拟机规范》的要求，在执行monitorenter指 令时，首先要去尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经持有了那个对象的锁，就把锁的计数器的值增加一，而在执行monitorexit指令时会将锁计数器的值减一。一旦计数器的值为零，锁随即就被释放了。如果获取对象锁失败，那当前线程就应当被阻塞等待，直到请求锁定的对象被持有它的线程释放为止。</p>
<p><strong>Synchronized注意点</strong></p>
<ul>
<li>被synchronized修饰的同步块对同一条线程来说是可以重入的。这意味着同一线程反复进入同步块也不会出现自己把自己锁死的情况。</li>
<li>被synchronized修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入。这意味着无法像处理某些数据库中的锁那样，强制已获取锁的线程释放锁;也无法强制正在等待锁的线程中断等待或超时退出。</li>
</ul>
<p><strong>Synchronized执行成本</strong></p>
<p>Synchronized是一个重量级的操作，有经验的程序员都只会在确实有必要的情况下才使用这种操作。虚拟机本身也会进行一些优化，比如在通知系统之前加入一段自选等待过程。</p>
<hr>
<p>JDK5以后加入了LOCK，重入锁(ReentrantLock)是Lock接口一种常见的实现方式。</p>
<p><strong>ReentrantLock相比Synchronized增加了一些高级功能，主要有以下三项：等待可中断、可实现公平锁以及所可以绑定多个条件。</strong></p>
<p><strong>等待可中断：</strong>是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助。</p>
<p><strong>公平锁：</strong>是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock在默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。不过一旦使用了公平锁，将会导致ReentrantLock的性能急剧下降，会明显影响吞吐量。</p>
<p><strong>锁绑定多个条件：</strong>是指一个ReentrantLock对象可以同时绑定多个Condition对象。在synchronized中，锁对象的wait()跟它的notify()或者notifyAll()方法配合可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外添加一个锁；而ReentrantLock则无须这样做，多次调用newCondition()方法即可。</p>
<hr>
<p><strong>Synchronized和ReentrantLock的对比</strong></p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211018200633486.png" alt="image-20211018200633486"></p>
<p><strong>如果Synchronized和ReentrantLock都满足的情况下，优先推荐使用Synchronized</strong></p>
<ul>
<li>synchronized是在Java语法层面的同步，足够清晰，也足够简单。每个Java程序员都熟悉synchronized,但J.U.C中 的Lock接口则并非如此。因此在只需要基础的同步功能时，更推荐synchronized。</li>
<li>Lock应该确保在finally块中释放锁，否则一旦受同步保护的代码块中抛出异常，则有可能永远不会释放持有的锁。这一-点必须由程序员自己来保证，而使用synchronized的话则可以由Java虛拟机来确保即使出现异常，锁也能被自动释放。</li>
<li>尽管在JDK 5时代ReentrantLock曾经在性能上领先过synchronized,但这已经是十多年之前的胜利了。从长远来看，Java虛拟机更容易针对sy nchronized来进行优化，因为Java虚拟机可以在线程和对象的元数据中记录synchronized中锁的相关信息，而使用J.U.C中的Lock的话，Java虛 拟机是很难得知具体哪些锁对象是由特定线程锁持有的。</li>
</ul>
<h4 id="13-2-2-2-非阻塞同步"><a href="#13-2-2-2-非阻塞同步" class="headerlink" title="13.2.2.2 非阻塞同步"></a>13.2.2.2 非阻塞同步</h4><p><strong>非同步阻塞：</strong>就是不管风险，先进行操作，如果没有其他线程争用共享数据，那操作就直接成功了;如果共享的数据的确被争用，产生了冲突，那再进行其他的补偿措施，最常用的补偿措施是不断地重试，直到出现没有竞争的共享数据为止。</p>
<hr>
<p><strong>其他名词：</strong>乐观锁、无锁编程。</p>
<hr>
<p>常见的乐观锁实现比如CAS(Java最终使用的也是这个)，它的底层基于比较并交换（Compare-and-swap）指令。</p>
<p><strong>CAS实现原理</strong></p>
<p>CAS指令需要有三个操作数，分别是内存位置(在Java中可以简单地理解为变量的内存地址，用V表示)、旧的预期值(用A表示)和准备设置的新值(用B表示)。CAS指令执行时，当且仅当V符合A时，处理器才会用B更新V的值，否则它就不执行更新。但是，不管是否更新了V的值，都会返回V的旧值，上述的处理过程是一个原子操作，执行期间不会被其他线程中断。</p>
<p><strong>CAS存在的问题</strong></p>
<p>CAS从语义上来说并不是真正完美的，它存在一个逻辑漏洞：如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然为A值，那就能说明它的值没有被其他线程改变过了吗?这是不能的，因为如果在这段期间它的值曾经被改成B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA问题”。</p>
<p><strong>解决方案：</strong>JUC包提供了一个带有标记的原子引用类AtomicStampedReference，它可以通过控制变量版本来保证CAS的正确性，但是性能方面还不如互斥同步。</p>
<h4 id="13-2-2-3-无同步方案"><a href="#13-2-2-3-无同步方案" class="headerlink" title="13.2.2.3 无同步方案"></a>13.2.2.3 无同步方案</h4><p><strong>无同步：</strong>如果能让一个方法本来就不涉及共享数据，那他自然就不需要任何同步措施去保证其正确性。因此有一些代码天生就是线程安全的。</p>
<ul>
<li><p>可重入代码(纯引用)：可以在代码执行的任何时刻中断它，转而去执行另一段代码，而在控制权返回后，原来的程序不会出现错误，也不会对结果有所影响。</p>
<p>判断代码是否具备可重入性：如果一个方法的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。</p>
</li>
<li><p>线程本地存储：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。</p>
<p>常见的：消费队列、服务端请求</p>
</li>
</ul>
<h2 id="13-3-锁优化"><a href="#13-3-锁优化" class="headerlink" title="13.3 锁优化"></a>13.3 锁优化</h2><p>高效并发是从JDK 5升级到JDK 6后一项重要的改进项，HotSpot虛 拟机开发团队在这个版本上花费了大量的资源去实现各种锁优化技术，如适应性自旋( Adaptive Spinning)、锁消除( Lock Elimination)、锁膨胀(Lock Coarsening)、轻量级锁(Lightweight Locking)、偏向锁( Biased Locking)等，这些技术都是为了在线程之间更高效地共享数据及解决竞争问题，从而提高程序的执行效率。</p>
<h3 id="13-3-1-自旋锁与自适应自旋"><a href="#13-3-1-自旋锁与自适应自旋" class="headerlink" title="13.3.1 自旋锁与自适应自旋"></a>13.3.1 自旋锁与自适应自旋</h3><p><strong>原因</strong>：共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。</p>
<p><strong>解决方案：</strong>我们可以让后面请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只须让线程执行一个<strong>忙循环</strong>(自旋)，这项技术就是所谓的自旋锁。</p>
<hr>
<p><strong>优势：</strong>如果所被占用的时间很短，那么自旋锁效果就非常好。</p>
<p><strong>缺点：</strong>如果被占用的时间长，那么自旋锁只会白白浪费资源。</p>
<hr>
<p><strong>自适应自旋锁</strong>：自适应意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。</p>
<p>前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待持续相对更长的时间，比如持续100次忙循环。另一方面，如果对于某个锁，自旋很少成功获得过锁，那在以后要获取这个锁时将有可能直接省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行时间的增长及性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越精准，虚拟机就会变得越来越“聪明”了。</p>
<h3 id="13-3-2-锁消除"><a href="#13-3-2-锁消除" class="headerlink" title="13.3.2 锁消除"></a>13.3.2 锁消除</h3><p><strong>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。</strong></p>
<p><strong>判定依据</strong>：来源于逃逸分析的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须再进行。</p>
<h3 id="13-3-3-锁粗化"><a href="#13-3-3-锁粗化" class="headerlink" title="13.3.3 锁粗化"></a>13.3.3 锁粗化</h3><p>原则上，我们推荐使用同步代码块中的作用范围尽可能小，但是一系列连续操作都对同一个对象进行加锁和解锁那就是对性能的浪费了。</p>
<h3 id="13-3-4-轻量级锁"><a href="#13-3-4-轻量级锁" class="headerlink" title="13.3.4 轻量级锁"></a>13.3.4 轻量级锁</h3><p>轻量级锁：<strong>设计的初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗</strong>。</p>
<hr>
<p><strong>对象头存储锁标志：</strong></p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211019101348032.png" alt="image-20211019101348032"></p>
<p>我们简单回顾了对象的内存布局后，接下来就可以介绍轻量级锁的工作过程了:在代码即将进入同步块的时候，如果此同步对象没有被锁定(锁标志位为“01”状态)，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录(Lock Record)的空间，用于存储锁对象目前的M ark Word的拷贝(官方为这份拷贝加了一个Displaced前缀，即DisplacedMarkWord)，这时候线程堆栈与对象头的状态如图13-<br>3所示。</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211019114924143.png" alt="image-20211019114924143"></p>
<p>然后，虚拟机将使用CAS操作尝试把对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功了，即代表该线程拥有了这个对象的锁，并且对象Mark Word的锁标志位(Mark Word的最后两个比特)将转变为“00”，表示此对象处于轻量级锁定状态。这时候线程堆栈与对象头的状态如下图所示。</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211019115307343.png" alt="image-20211019115307343"></p>
<p>如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对象的锁，那直接进入同步块继续执行就可以了，否则就说明这个锁对象已经被其他线程抢占了。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁，锁标志的状态值变为“10”，此时Mark Word中存储的就是指向重量级锁(互斥量)的指针，后面等待锁的线程也必须进入阻塞状态。</p>
<p><strong>轻量级锁：</strong>轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”这- -经验法则。如果没有竞争，轻量级锁便通过CAS操作成功避免了使用互斥量的开销;但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢。</p>
<h3 id="13-3-5-偏向锁"><a href="#13-3-5-偏向锁" class="headerlink" title="13.3.5 偏向锁"></a>13.3.5 偏向锁</h3><p><strong>偏向锁：</strong>目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不去做了。</p>
<p>偏向锁中的“偏”，就是偏心的“偏”、偏袒的“偏”。<strong>它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步</strong>。</p>
<p>如果读者理解了前面轻量级锁中关于对象头MarkWord与线程之间的操作过程，那偏向锁的原理就会很容易理解。假设当前虚拟机启用了偏向锁(启用参数-XX: +UseBiased Locking,这是自JDK 6起HotSpot虚拟机的默认值)，那么当锁对象第一次 被线程获取的时候，虛拟机将会把对象头中的标志位设置为“01”、把偏向模式设置为“1”，表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的M ark Word之中。如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作(例如加锁、解锁及对MarkWord的更新操作等)。</p>
<p>一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式就马上宣告结束。根据锁对象目前是否处于被锁定的状态决定是否撤销偏向( 偏向模式设置为“0”)，撤销后标志位恢复到未锁定(标志位为“01”)或轻量级锁定(标志位为“00”)的状态，后续的同步操作就按照上面介绍的轻量级锁那样去执行。偏向锁、轻量级锁的状态转化及对象MarkWord的关系如图13-5所示。</p>
<p><img src="https://ccbigsbyzdqphoto.oss-cn-guangzhou.aliyuncs.com/image-20211019141341989.png" alt="image-20211019141341989"></p>
<p>因此，当一个对象已经计算过一致性哈希码后，它就再也无法进入偏向锁状态了;而当一个对象当前正处于偏向锁状态，又收到需要计算其一致性哈希码请求1时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁。在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类里有字段可以记录非加锁状态(标志位为“01”)下 的M ark Word,其中自然可以存储原来的哈希码。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>虚拟机参数配置</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>+XX: CompactFields参数值为true</td>
<td>那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。</td>
</tr>
<tr>
<td>-verbose:gc</td>
<td>参数-verbose:gc 表示输出虚拟机中GC的详细情况.</td>
</tr>
<tr>
<td>-XX:PretenureSizeThreshold&#x3D;3MB</td>
<td>设置满3MB的对象直接分配在老年代</td>
</tr>
<tr>
<td>-XX:ParallelGCThread&#x3D;4</td>
<td>设置并行垃圾回收器的线程为4个，该设置最好与处理器的数目相同</td>
</tr>
<tr>
<td>-XX:MaxGCPauseMillis&#x3D;100</td>
<td>设置每次新生代每次收集器垃圾回收的最长时间，如果无法满足该时间，JVM会自动调整新生代区的大小，以满足该值</td>
</tr>
<tr>
<td>-XX:UseConcMarkSweepGC</td>
<td>设置JVM堆的老年代使用CMS并发收集器，设置该参数后，-XX:NewRatio参数失效，但-Xmn参数依然有效</td>
</tr>
<tr>
<td>-XX:+UseCMSCompactAtFullCollection</td>
<td>打开对老年代的压缩，可能会影响性能，但可以消除堆碎片</td>
</tr>
<tr>
<td>-XMS</td>
<td>初堆</td>
</tr>
<tr>
<td>-XMN</td>
<td>年轻代</td>
</tr>
<tr>
<td>-XMX</td>
<td>最大堆</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">DingQuan Zuo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/09/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8E%9F%E7%90%86/">http://example.com/2021/09/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8E%9F%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">ccbigs blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post_share"><div class="social-share" data-image="/img/ahead.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/09/12/%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94ElasticSearch/" title="中间件——ElasticSearch"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">中间件——ElasticSearch</div></div></a></div><div class="next-post pull-right"><a href="/2021/08/22/%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94KAFKA/" title="中间件——KAFKA"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">中间件——KAFKA</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/02/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-Java/" title="数据结构与算法——JAVA实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="title">数据结构与算法——JAVA实现</div></div></a></div><div><a href="/2021/09/14/JAVA%E2%80%94%E2%80%94JUC/" title="JAVA——JUC"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-14</div><div class="title">JAVA——JUC</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/ahead.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">DingQuan Zuo</div><div class="author-info__description">计算机很适合我这样的蠢人学，因为代码就在那里</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ccbigs" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://blog.csdn.net/zuodingquan666" target="_blank" title="CSDN"><i class="fas fa-c" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1692062014@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E8%87%AA%E5%8A%A8%E7%AE%A1%E7%90%86"><span class="toc-text">2.内存自动管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">2.1 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F"><span class="toc-text">2.2 运行时数据区域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-text">2.2.1 程序计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-text">2.2.2 Java虚拟机栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-text">2.2.3 本地方法栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-Java%E5%A0%86"><span class="toc-text">2.2.4 Java堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-5-%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-text">2.2.5 方法区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-6-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-text">2.2.6 运行时常量池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-7-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-text">2.2.7 直接内存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E8%A7%A3%E5%AF%86"><span class="toc-text">2.3 HotSpot虚拟机对象解密</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">2.3.1 对象的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-text">2.3.2 对象的内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="toc-text">2.3.3 对象的访问定位</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="toc-text">3.垃圾收集器与回收策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">3.1 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB%EF%BC%9F"><span class="toc-text">3.2 对象已死？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="toc-text">3.2.1 引用计数算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-text">3.2.2 可达性分析算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-%E5%86%8D%E8%B0%88%E5%BC%95%E7%94%A8"><span class="toc-text">3.2.3 再谈引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4-%E7%94%9F%E5%AD%98%E8%BF%98%E6%98%AF%E6%AD%BB%E4%BA%A1"><span class="toc-text">3.2.4 生存还是死亡?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-5-%E5%9B%9E%E6%94%B6%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-text">3.2.5 回收方法区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-text">3.3 垃圾收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%90%86%E8%AE%BA"><span class="toc-text">3.3.1 分代收集理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-text">3.3.2 标记-清除算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-text">3.3.3 标记-复制算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-5-%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-text">3.3.5 标记-整理算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-HotSpot%E7%9A%84%E7%AE%97%E6%B3%95%E7%BB%86%E8%8A%82%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.4 HotSpot的算法细节实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E6%A0%B9%E8%8A%82%E7%82%B9%E6%9E%9A%E4%B8%BE"><span class="toc-text">3.4.1 根节点枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E5%AE%89%E5%85%A8%E7%82%B9"><span class="toc-text">3.4.2 安全点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F"><span class="toc-text">3.4.3 安全区域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-4-%E8%AE%B0%E5%BF%86%E9%9B%86%E4%B8%8E%E5%8D%A1%E8%A1%A8"><span class="toc-text">3.4.4 记忆集与卡表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-5-%E5%86%99%E5%B1%8F%E9%9A%9C"><span class="toc-text">3.4.5 写屏障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-6-%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-text">3.4.6 并发的可达性分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E7%BB%8F%E5%85%B8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">3.5 经典垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-Serial%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">3.5.1 Serial收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2-ParNew%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">3.5.2 ParNew收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-3-Parallel-Scavenge%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">3.5.3 Parallel Scavenge收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-4-Serial-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">3.5.4 Serial Old收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-5-Parallel-old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">3.5.5 Parallel old 收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-6-CMS%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">3.5.6 CMS收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-7-G1%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">3.5.7 G1收集器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E4%BD%8E%E5%BB%B6%E8%BF%9F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">3.6 低延迟垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-1-shenandoah%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">3.6.1 shenandoah收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-2-ZGC%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">3.6.2 ZGC收集器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-%E5%AE%9E%E6%88%98-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="toc-text">3.8 实战:内存分配与回收策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-1-%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%85%88%E5%9C%A8Eden%E5%88%86%E9%85%8D"><span class="toc-text">3.8.1 对象优先在Eden分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-2-%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-text">3.8.2 大对象直接进入老年代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-3-%E9%95%BF%E6%9C%9F%E5%AD%98%E6%B4%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-text">3.8.3 长期存活的对象进入老年代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-4-%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1%E5%B9%B4%E9%BE%84%E5%88%A4%E5%AE%9A"><span class="toc-text">3.8.4 动态对象年龄判定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-5-%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D"><span class="toc-text">3.8.5 空间分配担保</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7"><span class="toc-text">4.虚拟机性能监控、故障处理工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%9F%BA%E7%A1%80%E6%95%85%E9%9A%9C%E5%B7%A5%E5%85%B7"><span class="toc-text">4.2 基础故障工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-jsp-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%9B%E7%A8%8B%E7%8A%B6%E5%86%B5%E5%B7%A5%E5%85%B7"><span class="toc-text">4.2.1 jsp:虚拟机进程状况工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-jstat-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF%E7%9B%91%E8%A7%86%E5%B7%A5%E5%85%B7"><span class="toc-text">4.2.2 jstat:虚拟机统计信息监视工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-jinfo-Java%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E5%B7%A5%E5%85%B7"><span class="toc-text">4.2.3 jinfo:Java配置信息工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4-jmap-Java%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8F%E5%B7%A5%E5%85%B7"><span class="toc-text">4.2.4 jmap:Java内存映像工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-5-jhat-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A0%86%E8%BD%AC%E5%82%A8%E5%BF%AB%E7%85%A7%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-text">4.2.5 jhat:虚拟机堆转储快照分析工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-6-jstack-Java%E5%A0%86%E6%A0%88%E8%B7%9F%E8%B8%AA%E5%B7%A5%E5%85%B7"><span class="toc-text">4.2.6 jstack:Java堆栈跟踪工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7"><span class="toc-text">4.3 可视化故障处理工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-JHSDB-%E5%9F%BA%E4%BA%8E%E6%9C%8D%E5%8A%A1%E6%80%A7%E4%BB%A3%E7%90%86%E7%9A%84%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-text">4.3.1 JHSDB:基于服务性代理的调试工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-JConsole-Java%E7%9B%91%E8%A7%86%E4%B8%8E%E7%AE%A1%E7%90%86%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="toc-text">4.3.2 JConsole:Java监视与管理控制台</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-VisualVM-%E5%A4%9A%E5%90%88-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7"><span class="toc-text">4.3.3 VisualVM:多合-故障处理工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-4-Java-Misssion-Control-%E5%8F%AF%E6%8C%81%E7%BB%AD%E5%9C%A8%E7%BA%BF%E7%9A%84%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7"><span class="toc-text">4.3.4 Java Misssion Control:可持续在线的监控工具</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98"><span class="toc-text">5.调优案例分析与实战</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-text">5.2 案例分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-%E5%A4%A7%E5%86%85%E5%AD%98%E7%A1%AC%E4%BB%B6%E4%B8%8A%E7%9A%84%E7%A8%8B%E5%BA%8F%E9%83%A8%E7%BD%B2%E7%AD%96%E7%95%A5"><span class="toc-text">5.2.1 大内存硬件上的程序部署策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-%E9%9B%86%E7%BE%A4%E9%97%B4%E5%90%8C%E6%AD%A5%E5%AF%BC%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-text">5.2.2 集群间同步导致的内存溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3-%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E5%AF%BC%E8%87%B4%E7%9A%84%E6%BA%A2%E5%87%BA%E9%94%99%E8%AF%AF"><span class="toc-text">5.2.3 堆外内存导致的溢出错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-4-%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4%E5%AF%BC%E8%87%B4%E7%B3%BB%E7%BB%9F%E7%BC%93%E6%85%A2"><span class="toc-text">5.2.4 外部命令导致系统缓慢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-5-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%9B%E7%A8%8B%E5%B4%A9%E6%BA%83"><span class="toc-text">5.2.5 服务器虚拟机进程崩溃</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-6-%E4%B8%8D%E6%81%B0%E5%BD%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E8%BF%87%E5%A4%A7"><span class="toc-text">5.2.6 不恰当数据结构导致内存占用过大</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-7-%E7%94%B1Windows%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%AF%BC%E8%87%B4%E7%9A%84%E9%95%BF%E6%97%B6%E9%97%B4%E5%81%9C%E9%A1%BF"><span class="toc-text">5.2.7 由Windows虚拟内存导致的长时间停顿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-8-%E7%94%B1%E5%AE%89%E5%85%A8%E7%82%B9%E5%AF%BC%E8%87%B4%E9%95%BF%E6%97%B6%E9%97%B4%E5%81%9C%E9%A1%BF"><span class="toc-text">5.2.8 由安全点导致长时间停顿</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-text">6.字节码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-7-%E5%B1%9E%E6%80%A7%E8%A1%A8%E9%9B%86%E5%90%88"><span class="toc-text">6.3.7 属性表集合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B"><span class="toc-text">6.4 字节码指令简介</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-text">7.虚拟机类加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">7.1 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-text">7.2 类加载的时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-text">7.3 类加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-1-%E5%8A%A0%E8%BD%BD"><span class="toc-text">7.3.1 加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-2-%E9%AA%8C%E8%AF%81"><span class="toc-text">7.3.2 验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-3-%E5%87%86%E5%A4%87"><span class="toc-text">7.3.3 准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-4-%E8%A7%A3%E6%9E%90"><span class="toc-text">7.3.4 解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-5-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">7.3.5 初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">7.4 类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-1-%E7%B1%BB%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">7.4.1 类与类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-2-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-text">7.4.2 双亲委派模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-3-%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-text">7.4.3 破坏双亲委派模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-Java%E6%A8%A1%E5%9D%97%E5%8C%96%E7%B3%BB%E7%BB%9F"><span class="toc-text">7.5 Java模块化系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-2-%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8B%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">7.5.2 模块化下的类加载器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="toc-text">8.虚拟机字节码执行引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1%E6%A6%82%E8%BF%B0"><span class="toc-text">8.1概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84"><span class="toc-text">8.2 运行时栈帧结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-1-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="toc-text">8.2.1 局部变量表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-2-%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88"><span class="toc-text">8.2.2 操作数栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-3-%E5%8A%A8%E6%80%81%E8%BF%9E%E6%8E%A5"><span class="toc-text">8.2.3 动态连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-4-%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="toc-text">8.2.4 方法返回地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-5-%E9%99%84%E5%8A%A0%E4%BF%A1%E6%81%AF"><span class="toc-text">8.2.5 附加信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-text">8.3 方法的调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-1-%E8%A7%A3%E6%9E%90"><span class="toc-text">8.3.1 解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-2-%E5%88%86%E6%B4%BE"><span class="toc-text">8.3.2 分派</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-2-1-%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE"><span class="toc-text">8.3.2.1 静态分派</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-2-2-%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE"><span class="toc-text">8.3.2.2 动态分派</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-2-3-%E5%8D%95%E5%88%86%E6%B4%BE%E4%B8%8E%E5%A4%9A%E5%88%86%E6%B4%BE"><span class="toc-text">8.3.2.3 单分派与多分派</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-2-4-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE%E5%AE%9E%E7%8E%B0"><span class="toc-text">8.3.2.4 虚拟机动态分派实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81"><span class="toc-text">8.4 动态类型语言支持</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A1%88%E4%BE%8B%E4%B8%8E%E5%AE%9E%E6%88%98"><span class="toc-text">9.类加载及执行子系统的案例与实战</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">9.1 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-text">9.2 案例分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-4-Backport%E5%B7%A5%E5%85%B7-Java%E7%9A%84%E6%97%B6%E5%85%89%E6%9C%BA%E5%99%A8"><span class="toc-text">9.2.4 Backport工具:Java的时光机器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-text">10.前端编译与优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-Java%E8%AF%AD%E6%B3%95%E7%B3%96%E7%9A%84%E5%91%B3%E9%81%93"><span class="toc-text">10.3 Java语法糖的味道</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-1-%E6%B3%9B%E5%9E%8B"><span class="toc-text">10.3.1 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-1-1-Java%E4%B8%8EC-%E7%9A%84%E6%B3%9B%E5%9E%8B"><span class="toc-text">10.3.1.1 Java与C#的泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-1-2-%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%8E%86%E5%8F%B2%E8%83%8C%E6%99%AF"><span class="toc-text">10.3.1.2 泛型的历史背景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-1-3-%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-text">10.3.1.3 类型擦除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-2-%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E3%80%81%E6%8B%86%E7%AE%B1%E4%B8%8E%E9%81%8D%E5%8E%86%E5%BE%AA%E7%8E%AF"><span class="toc-text">10.3.2 自动装箱、拆箱与遍历循环</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-text">11.后端编译与优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">11.1 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-text">11.2 即时编译器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-1-%E8%A7%A3%E9%87%8A%E5%99%A8%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-text">11.2.1 解释器与编译器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-2-%E7%BC%96%E8%AF%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-text">11.2.2 编译对象与触发条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-3-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-text">11.2.3 编译过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-%E6%8F%90%E5%89%8D%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-text">11.3 提前编译器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-4-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="toc-text">11.4 编译器优化技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-1-%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88"><span class="toc-text">11.4.1 优化技术概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-2-%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94"><span class="toc-text">11.4.2 方法内联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-3-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="toc-text">11.4.3 逃逸分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-4-%E5%85%AC%E5%85%B1%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B6%88%E9%99%A4"><span class="toc-text">11.4.4 公共子表达式消除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-5-%E6%95%B0%E7%BB%84%E8%BE%B9%E7%95%8C%E6%A3%80%E6%9F%A5%E6%B6%88%E9%99%A4"><span class="toc-text">11.4.5 数组边界检查消除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-text">12.Java内存模型与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">12.1 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-%E7%A1%AC%E4%BB%B6%E7%9A%84%E6%95%88%E7%8E%87%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">12.2 硬件的效率与一致性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-text">12.3 Java内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-1-%E4%B8%BB%E5%86%85%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98"><span class="toc-text">12.3.1 主内存与工作内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-2-%E5%86%85%E5%AD%98%E9%97%B4%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C"><span class="toc-text">12.3.2 内存间交互操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-3-%E5%AF%B9%E4%BA%8Evolatile%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E7%89%B9%E6%AE%8A%E8%A7%84%E5%88%99"><span class="toc-text">12.3.3 对于volatile型变量的特殊规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-4-%E9%92%88%E5%AF%B9long%E5%92%8Cdouble%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E7%89%B9%E6%AE%8A%E8%A7%84%E5%88%99"><span class="toc-text">12.3.4 针对long和double型变量的特殊规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-5-%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E5%8F%AF%E8%BF%9B%E8%A1%8C%E4%B8%8E%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-text">12.3.5 原子性、可进行与有序性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-5-1-%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-text">12.3.5.1 原子性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-5-2-%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-text">12.3.5.2 可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-5-3-%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-text">12.3.5.3 有序性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-6-%E5%85%88%E8%A1%8C%E5%8F%91%E7%94%9F%E5%8E%9F%E5%88%99"><span class="toc-text">12.3.6 先行发生原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-4-Java%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-text">12.4 Java与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">12.4.1 线程的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-1-1-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="toc-text">12.4.1.1 内核线程实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-1-2-%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="toc-text">12.4.1.2 用户线程实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-1-3-%E6%B7%B7%E5%90%88%E5%AE%9E%E7%8E%B0"><span class="toc-text">12.4.1.3 混合实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-1-4-Java%E7%BA%BF%E7%A8%8B%E5%9C%B0%E5%AE%9E%E7%8E%B0"><span class="toc-text">12.4.1.4 Java线程地实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-2-Java%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-text">12.4.2 Java线程调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-3-%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-text">12.4.3 状态转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-5-Java%E4%B8%8E%E5%8D%8F%E7%A8%8B"><span class="toc-text">12.5 Java与协程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-1-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B1%80%E9%99%90"><span class="toc-text">12.5.1 内核线程的局限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-2-%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%A4%8D%E8%8B%8F"><span class="toc-text">12.5.2 协程的复苏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-3-Java%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">12.5.3 Java的解决方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96"><span class="toc-text">13 线程安全与锁优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-text">13.2 线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-1-Java%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-text">13.2.1 Java语言中的线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-1-1-%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-text">13.2.1.1 不可变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-1-2-%E7%BB%9D%E5%AF%B9%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-text">13.2.1.2 绝对线程安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-1-3-%E7%9B%B8%E5%AF%B9%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-text">13.2.1.3 相对线程安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-1-4-%E7%BA%BF%E7%A8%8B%E5%85%BC%E5%AE%B9"><span class="toc-text">13.3.1.4 线程兼容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-1-5-%E7%BA%BF%E7%A8%8B%E5%AF%B9%E7%AB%8B"><span class="toc-text">13.3.1.5 线程对立</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-text">13.2.2 线程安全的实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-2-1-%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5"><span class="toc-text">13.2.2.1 互斥同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-2-2-%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5"><span class="toc-text">13.2.2.2 非阻塞同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-2-3-%E6%97%A0%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88"><span class="toc-text">13.2.2.3 无同步方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-3-%E9%94%81%E4%BC%98%E5%8C%96"><span class="toc-text">13.3 锁优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-1-%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8E%E8%87%AA%E9%80%82%E5%BA%94%E8%87%AA%E6%97%8B"><span class="toc-text">13.3.1 自旋锁与自适应自旋</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-2-%E9%94%81%E6%B6%88%E9%99%A4"><span class="toc-text">13.3.2 锁消除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-3-%E9%94%81%E7%B2%97%E5%8C%96"><span class="toc-text">13.3.3 锁粗化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-4-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-text">13.3.4 轻量级锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-5-%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-text">13.3.5 偏向锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-text">附录</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/22/%E9%BB%91%E7%9A%AE%E4%B9%A6%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/" title="黑皮书——计算机网络自顶向下方法">黑皮书——计算机网络自顶向下方法</a><time datetime="2024-10-22T12:14:56.000Z" title="发表于 2024-10-22 20:14:56">2024-10-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/21/appInstall%E2%80%94%E2%80%94Java%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/" title="appInstall——Java安装步骤">appInstall——Java安装步骤</a><time datetime="2024-10-21T02:20:13.000Z" title="发表于 2024-10-21 10:20:13">2024-10-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/15/Rust%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/" title="Rust 程序设计语言">Rust 程序设计语言</a><time datetime="2024-09-15T11:19:19.000Z" title="发表于 2024-09-15 19:19:19">2024-09-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/1558.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By DingQuan Zuo</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">道可道，非恒道也！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>